Directory structure:
└── scraper/
    ├── University Data.xlsx
    ├── config.py
    ├── crawler_data.db
    ├── crawler_data.db-shm
    ├── crawler_data.db-wal
    ├── ingest.py
    ├── main.py
    ├── results.csv
    ├── analysis/
    │   ├── __init__.py
    │   ├── ai_evaluator.py
    │   ├── application_url_utils.py
    │   ├── external_system_url_generator.py
    │   ├── link_extractor.py
    │   ├── page_analyzer.py
    │   ├── static_application_urls.py
    │   └── __pycache__/
    ├── crawler/
    │   ├── __init__.py
    │   ├── fetcher.py
    │   ├── monitor.py
    │   ├── queue.py
    │   ├── shutdown.py
    │   ├── worker.py
    │   └── __pycache__/
    ├── database/
    │   ├── __init__.py
    │   ├── db_operations.py
    │   ├── metrics_storage.py
    │   └── __pycache__/
    ├── models/
    │   ├── __init__.py
    │   ├── application_page.py
    │   ├── checkpoint_manager.py
    │   ├── crawl_stats.py
    │   ├── state_manager.py
    │   └── __pycache__/
    ├── old/
    ├── old_async_crawler/
    ├── old_focused_crawler/
    ├── old_logs/
    ├── output/
    │   ├── __init__.py
    │   ├── exporter.py
    │   ├── how_to_apply_report.py
    │   ├── report_generator.py
    │   ├── special_cases.py
    │   └── __pycache__/
    ├── outputs/
    └── utils/
        ├── __init__.py
        ├── encoding.py
        ├── logging_config.py
        ├── url_utils.py
        └── __pycache__/

================================================
File: University Data.xlsx
================================================
[Non-text file]


================================================
File: config.py
================================================
"""
Configuration settings for the University Application Crawler
"""

import os
import sys
from typing import Dict, List, Set, Any, Optional

from universities import SEED_UNIVERSITIES as universities


class Config:
    """Central configuration for the crawler."""

    #
    # University Targets
    #

    # List of seed universities to crawl
    SEED_UNIVERSITIES = universities

    # Known admission subdomains to add as seeds
    ADMISSION_SUBDOMAINS = {
        # "mit.edu": ["admissions.mit.edu", "apply.mit.edu"],
        # "stanford.edu": [
        #     "admission.stanford.edu",
        #     "apply.stanford.edu",
        #     "admissions.stanford.edu",
        #     "undergrad.stanford.edu",
        # ],
        # "harvard.edu": ["admissions.harvard.edu", "college.harvard.edu/admissions"],
        # "princeton.edu": ["admission.princeton.edu"],
        # "yale.edu": ["admissions.yale.edu", "apply.yale.edu"],
    }

    #
    # Crawling Settings
    #

    # Depth limits
    MAX_DEPTH = 15  # Regular crawl depth
    MAX_ADMISSION_DEPTH = 20  # Deeper crawl for admission-related domains

    # Request settings
    REQUEST_TIMEOUT = 15  # Seconds
    REQUEST_DELAY = 1  # Seconds between requests
    RESPECT_ROBOTS_TXT = True  # Whether to respect robots.txt

    # URL limits
    MAX_URLS_PER_DOMAIN = 600  # Maximum URLs to crawl per domain
    MAX_TOTAL_URLS = 2000000  # Maximum total URLs to crawl

    # Worker settings
    NUM_WORKERS = 12  # Number of concurrent worker tasks

    #
    # Checkpoint Settings
    #

    # Whether to use incremental checkpoints (process in batches during crawling)
    USE_CHECKPOINTS = True

    # Time between checkpoint evaluations in seconds
    CHECKPOINT_INTERVAL = 60

    # Minimum number of application pages to trigger batch evaluation
    MIN_BATCH_SIZE = 10

    # Maximum number of pages to process in one batch
    MAX_BATCH_SIZE = 30

    # Directory to store checkpoint data
    CHECKPOINT_DIR = "checkpoints"  # Relative to OUTPUT_DIR

    # Whether to generate incremental reports at each checkpoint
    CHECKPOINT_REPORTS = True

    #
    # Application Keywords and Indicators
    #

    # Application-related keywords
    APPLICATION_KEYWORDS = [
        "apply",
        "application",
        "admission",
        "admissions",
        "undergraduate",
        "freshman",
        "enroll",
        "register",
        "portal",
        "submit",
        "first-year",
        "transfer",
        "applicant",
        "prospective",
    ]

    # Direct application form indicators
    APPLICATION_FORM_INDICATORS = [
        "start application",
        "begin application",
        "submit application",
        "create account",
        "application form",
        "apply now",
        "start your application",
        "application status",
        "application portal",
        "common app",
        "common application",
        "coalition app",
    ]

    #
    # URL Patterns
    #

    # High-priority URL patterns - more specific patterns first
    HIGH_PRIORITY_PATTERNS = [
        "/apply/first-year",
        "/apply/transfer",
        "/apply/freshman",
        "/apply/undergraduate",
        "/apply/online",
        "/admission/apply",
        "/admission/application",
        "/admission/first-year",
        "/admission/undergraduate",
        "/admissions/apply",
        "/apply",
        "/admission",
        "/admissions",
        "/undergraduate",
    ]

    # URL patterns to exclude
    EXCLUDED_PATTERNS = [
        r"/news/",
        r"/events/",
        r"/calendar/",
        r"/people/",
        r"/profiles/",
        r"/faculty/",
        r"/staff/",
        r"/directory/",
        r"/search",
        r"/\d{4}/",
        r"/tag/",
        r"/category/",
        r"/archive/",
        r"/page/\d+",
        r"/feed/",
        r"/rss/",
        r"/login",
        r"/accounts/",
        r"/alumni/",
        r"/giving/",
        r"/support/",
        r"/donate/",
        r"/covid",
        r"/research/",
        r"/athletics/",
        r"/sports/",
        r"/about/",
        r"/contact/",
        r"/privacy/",
        r"/privacy-policy/",
        r"/terms/",
        r"/campus-map/",
        r"/campus-tour/",
        r"/privacy",
        r"/terms",
        r"/careers",
        r"/jobs",
        r"/employment",
        r"/opportunities",
        r"/opportunity",
        r"/visit",
        r"/tour",
    ]

    # File extensions to exclude
    EXCLUDED_EXTENSIONS = [
        ".pdf",
        ".jpg",
        ".jpeg",
        ".png",
        ".gif",
        ".svg",
        ".css",
        ".js",
        ".zip",
        ".tar",
        ".gz",
        ".rar",
        ".doc",
        ".docx",
        ".xls",
        ".xlsx",
        ".ppt",
        ".pptx",
        ".mp3",
        ".mp4",
        ".avi",
        ".mov",
    ]

    #
    # OpenAI Configuration
    #

    # Model settings
    MODEL_NAME = "gpt-4o-mini"  # Model to use for evaluation

    # API settings
    MAX_EVAL_BATCH = 10  # Evaluate this many URLs in one batch
    MAX_CONCURRENT_API_CALLS = 5  # Maximum concurrent API calls

    # OpenAI API key - load from environment
    OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
    if not OPENAI_API_KEY:
        print("WARNING: OPENAI_API_KEY environment variable not set")

    # Cost tracking
    PROMPT_TOKEN_COST = 0.00015  # Cost per 1K tokens for prompt
    COMPLETION_TOKEN_COST = 0.0006  # Cost per 1K tokens for completion
    CACHED_TOKEN_COST = 0.000075  # Cost per 1K tokens for cached prompt

    #
    # Database Settings
    #

    # SQLite settings
    USE_SQLITE = True  # Whether to use SQLite database
    DB_PATH = os.path.join(
        os.path.dirname(__file__), "crawler_data.db"
    )  # Database path

    #
    # User Agent Settings
    #

    # Primary user agent
    USER_AGENT = "University-Application-Crawler/1.0 (contact: ghoulbites777@gmail.com)"

    # User agent rotation settings
    USER_AGENT_ROTATION = True  # Whether to rotate user agents
    USER_AGENTS = [
        "University-Application-Crawler/1.0 (contact: ghoulbites777@gmail.com)",
        "UniversityApplicationFinder/1.0 (contact: ghoulbites777@gmail.com)",
        "EducationalCrawler/1.0 (contact: ghoulbites777@gmail.com)",
    ]

    #
    # Output Settings
    #

    # Output paths
    OUTPUT_DIR = "outputs"  # Directory for saving results
    REPORT_DIR = os.path.join(OUTPUT_DIR, "reports")  # Directory for reports

    # Output formats
    SAVE_HTML_REPORT = False  # Whether to generate HTML report
    SAVE_CSV = False  # Whether to export to CSV

    # Add How-to-Apply report generation
    GENERATE_HOW_TO_APPLY = True  # Whether to generate focused "How to Apply" report

    #
    # Logging Settings
    #

    # Log levels
    LOG_LEVEL = "INFO"

    # Log files
    LOG_FILE = "crawler.log"
    ERROR_LOG_FILE = "errors.log"

    @classmethod
    def validate(cls) -> bool:
        """Validate the configuration."""
        # Check for required settings
        if not cls.SEED_UNIVERSITIES:
            print("ERROR: No seed universities defined")
            return False

        # Validate API key if evaluation is enabled
        if not cls.OPENAI_API_KEY and not getattr(cls, "SKIP_EVALUATION", False):
            print("ERROR: OpenAI API key is required for evaluation")
            print(
                "Set the OPENAI_API_KEY environment variable or enable SKIP_EVALUATION"
            )
            return False

        # Validate checkpoint settings
        if cls.USE_CHECKPOINTS:
            if cls.MIN_BATCH_SIZE <= 0:
                print("ERROR: MIN_BATCH_SIZE must be greater than 0")
                return False
            if cls.MAX_BATCH_SIZE < cls.MIN_BATCH_SIZE:
                print(
                    "ERROR: MAX_BATCH_SIZE must be greater than or equal to MIN_BATCH_SIZE"
                )
                return False
            if cls.CHECKPOINT_INTERVAL <= 0:
                print("ERROR: CHECKPOINT_INTERVAL must be greater than 0")
                return False

        return True

    @classmethod
    def summarize(cls) -> Dict[str, Any]:
        """Return a summary of the configuration."""
        return {
            "universities": [u["name"] for u in cls.SEED_UNIVERSITIES],
            "max_depth": cls.MAX_DEPTH,
            "max_urls": cls.MAX_TOTAL_URLS,
            "num_workers": cls.NUM_WORKERS,
            "model": cls.MODEL_NAME,
            "use_database": cls.USE_SQLITE,
            "use_checkpoints": cls.USE_CHECKPOINTS,
            "checkpoint_interval": cls.CHECKPOINT_INTERVAL,
            "batch_size": f"{cls.MIN_BATCH_SIZE}-{cls.MAX_BATCH_SIZE}",
        }

    @classmethod
    def print_summary(cls) -> None:
        """Print a summary of the configuration."""
        summary = cls.summarize()
        print("\n=== Configuration Summary ===")
        print(f"Universities: {', '.join(summary['universities'])}")
        print(f"Max depth: {summary['max_depth']}")
        print(f"Max URLs: {summary['max_urls']}")
        print(f"Workers: {summary['num_workers']}")
        print(f"Model: {summary['model']}")
        print(f"Using database: {summary['use_database']}")

        # Add checkpoint settings to summary
        if cls.USE_CHECKPOINTS:
            print(f"Checkpoint interval: {summary['checkpoint_interval']}s")
            print(f"Batch size: {summary['batch_size']}")
        else:
            print("Checkpoints: Disabled")

        print("============================\n")

    @classmethod
    def update_from_args(cls, args):
        """Update configuration from command line arguments."""
        # Update basic settings
        if hasattr(args, "depth"):
            cls.MAX_DEPTH = args.depth
        if hasattr(args, "workers"):
            cls.NUM_WORKERS = args.workers
        if hasattr(args, "max_urls"):
            cls.MAX_TOTAL_URLS = args.max_urls
        if hasattr(args, "model"):
            cls.MODEL_NAME = args.model
        if hasattr(args, "use_db"):
            cls.USE_SQLITE = args.use_db
        if hasattr(args, "html_report"):
            cls.SAVE_HTML_REPORT = args.html_report
        if hasattr(args, "csv"):
            cls.SAVE_CSV = args.csv

        # Update checkpoint settings
        if hasattr(args, "disable_checkpoints"):
            cls.USE_CHECKPOINTS = not args.disable_checkpoints
        if hasattr(args, "checkpoint_interval"):
            cls.CHECKPOINT_INTERVAL = args.checkpoint_interval
        if hasattr(args, "min_batch_size"):
            cls.MIN_BATCH_SIZE = args.min_batch_size
        if hasattr(args, "max_batch_size"):
            cls.MAX_BATCH_SIZE = args.max_batch_size

        # Output directory
        if hasattr(args, "output_dir"):
            cls.OUTPUT_DIR = args.output_dir
            cls.REPORT_DIR = os.path.join(args.output_dir, "reports")

        # Update logging settings
        if hasattr(args, "log_level"):
            cls.LOG_LEVEL = args.log_level
        if hasattr(args, "log_file"):
            cls.LOG_FILE = args.log_file



================================================
File: crawler_data.db
================================================
[Non-text file]


================================================
File: crawler_data.db-shm
================================================
[Non-text file]


================================================
File: crawler_data.db-wal
================================================
[Non-text file]


================================================
File: ingest.py
================================================



================================================
File: main.py
================================================
"""
University Application Crawler - Main Application Entry Point

This script runs the crawler to find university application pages.
"""

import asyncio
import argparse
import os
import sys
import signal
import time
import atexit
from datetime import datetime
import uuid
import threading
from concurrent.futures import ThreadPoolExecutor

import aiohttp
from loguru import logger

from config import Config
from utils.logging_config import configure_logging
from crawler.queue import UniqueURLQueue
from crawler.worker import start_workers
from crawler.monitor import monitor_progress, explore_specific_application_paths
from crawler.shutdown import (
    check_for_shutdown,
    setup_signal_handlers,
    shutdown_controller,
)
from analysis.ai_evaluator import evaluate_all_applications, get_api_metrics
from output.exporter import save_results
from output.report_generator import ReportGenerator
from database.db_operations import (
    init_database,
    start_crawl_run,
    end_crawl_run,
    close_connection,
)
from database.metrics_storage import (
    save_metrics_to_db,
    save_application_pages,
    get_aggregated_metrics,
)
from models.crawl_stats import CrawlStats, APIMetrics
from models.state_manager import state_manager  # Use the global instance
from models.checkpoint_manager import CheckpointManager  # New import for checkpointing

# Global shutdown flag for force exit
_force_exit_event = threading.Event()

# Global thread pool executor for API calls
api_executor = ThreadPoolExecutor(max_workers=Config.MAX_CONCURRENT_API_CALLS)


def parse_arguments():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(description="University Application Crawler")

    # Basic configuration
    parser.add_argument(
        "-u",
        "--university",
        nargs="+",
        help="Specify universities to crawl (e.g., Stanford MIT)",
    )
    parser.add_argument(
        "-d",
        "--depth",
        type=int,
        default=Config.MAX_DEPTH,
        help=f"Maximum crawl depth (default: {Config.MAX_DEPTH})",
    )
    parser.add_argument(
        "-w",
        "--workers",
        type=int,
        default=Config.NUM_WORKERS,
        help=f"Number of worker tasks (default: {Config.NUM_WORKERS})",
    )
    parser.add_argument(
        "-m",
        "--max-urls",
        type=int,
        default=Config.MAX_TOTAL_URLS,
        help=f"Maximum URLs to crawl (default: {Config.MAX_TOTAL_URLS})",
    )

    # Output options
    parser.add_argument(
        "-o",
        "--output-dir",
        default="outputs",
        help="Directory to save outputs (default: outputs)",
    )
    parser.add_argument(
        "--html-report",
        action="store_true",
        help="Generate HTML report with visualizations",
    )
    parser.add_argument("--csv", action="store_true", help="Export results to CSV")

    # Database options
    parser.add_argument(
        "--use-db",
        action="store_true",
        default=Config.USE_SQLITE,
        help="Use SQLite database for storing results and metrics",
    )

    # Model options
    parser.add_argument(
        "--model",
        default=Config.MODEL_NAME,
        help=f"OpenAI model to use (default: {Config.MODEL_NAME})",
    )
    parser.add_argument(
        "--skip-evaluation",
        action="store_true",
        help="Skip AI evaluation of found pages",
    )

    # Logging options
    parser.add_argument(
        "--log-level",
        default="INFO",
        choices=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
        help="Set logging level (default: INFO)",
    )
    parser.add_argument(
        "--log-file", default="crawler.log", help="Log file path (default: crawler.log)"
    )

    # Checkpoint options
    parser.add_argument(
        "--checkpoint-interval",
        type=int,
        default=60,  # Default: check every 60 seconds
        help="Time between checkpoint evaluations in seconds (default: 60)",
    )
    parser.add_argument(
        "--min-batch-size",
        type=int,
        default=10,  # Default: minimum 10 pages to process
        help="Minimum number of pages to trigger a checkpoint (default: 10)",
    )
    parser.add_argument(
        "--max-batch-size",
        type=int,
        default=30,  # Default: maximum 30 pages per batch
        help="Maximum number of pages to process in one batch (default: 30)",
    )
    parser.add_argument(
        "--disable-checkpoints",
        action="store_true",
        help="Disable incremental checkpoints (process all at once)",
    )

    # Shutdown options
    parser.add_argument(
        "--shutdown-timeout",
        type=int,
        default=30,  # Default: 30 seconds before force exit
        help="Timeout in seconds before forcing program termination on shutdown (default: 30)",
    )

    return parser.parse_args()


def update_config_from_args(args):
    """Update configuration based on command line arguments."""
    Config.MAX_DEPTH = args.depth
    Config.NUM_WORKERS = args.workers
    Config.MAX_TOTAL_URLS = args.max_urls
    Config.MODEL_NAME = args.model
    Config.USE_SQLITE = args.use_db

    # Update universities if specified
    if args.university:
        # Filter existing universities or add them
        selected_universities = []
        university_names = [u.lower() for u in args.university]

        # First check existing ones
        for uni in Config.SEED_UNIVERSITIES:
            if uni["name"].lower() in university_names:
                selected_universities.append(uni)

        # Only use selected ones if any were found
        if selected_universities:
            Config.SEED_UNIVERSITIES = selected_universities
        else:
            logger.warning("No matching universities found in configuration")


async def prepare_url_queue(url_queue):
    """Prepare the URL queue with seed URLs."""
    for university in Config.SEED_UNIVERSITIES:
        # Add the main university domain
        # Use priority 0 for seed URLs
        await url_queue.put((0, university["base_url"], Config.MAX_DEPTH, university))

        # Add known admission subdomains as seeds
        university_domain = university["domain"]
        if university_domain in Config.ADMISSION_SUBDOMAINS:
            for subdomain in Config.ADMISSION_SUBDOMAINS[university_domain]:
                admission_url = f"https://{subdomain}/"
                logger.info(f"Adding admission seed URL: {admission_url}")
                # Use priority 0 for seed URLs
                await url_queue.put((0, admission_url, Config.MAX_DEPTH, university))

                # Add common application paths to these admission domains
                for path in [
                    "/apply",
                    "/first-year",
                    "/apply/first-year",
                    "/undergraduate",
                    "/apply/undergraduate",
                    "/freshman",
                    "/admission",
                    "/admissions",
                ]:
                    path_url = f"https://{subdomain}{path}"
                    logger.info(f"Adding admission path URL: {path_url}")
                    # Use priority 0 for seed URLs
                    await url_queue.put((0, path_url, Config.MAX_DEPTH, university))


# Function to force exit after timeout
def force_exit():
    """Force program termination after timeout."""
    if _force_exit_event.is_set():
        logger.critical("Force exit timeout reached. Terminating immediately.")
        os._exit(1)  # Force exit with error code


# Improved signal handler that sets a timer for force exit
def enhanced_signal_handler(signum, frame, timeout=30):
    """Signal handler with force exit capability."""
    logger.warning(
        f"\nReceived exit signal. Will force exit in {timeout} seconds if graceful shutdown fails."
    )

    # Set the force exit event
    _force_exit_event.set()

    # Start a timer for force exit
    timer = threading.Timer(timeout, force_exit)
    timer.daemon = True
    timer.start()

    # Also trigger the regular shutdown process
    asyncio.create_task(shutdown_controller.request_shutdown())


async def shutdown_resources():
    """Clean up resources during shutdown."""
    try:
        # Close database connection if it was used
        if Config.USE_SQLITE:
            await close_connection()
            logger.info("Database connection closed")

        # Shutdown thread pool executor
        api_executor.shutdown(wait=False)
        logger.info("Thread pool executor shutdown initiated")

    except Exception as e:
        logger.error(f"Error during resource cleanup: {e}")


async def main():
    """Main application function."""
    # Parse arguments
    args = parse_arguments()

    # Configure signal handlers with timeout for force exit
    signal.signal(
        signal.SIGINT,
        lambda signum, frame: enhanced_signal_handler(
            signum, frame, args.shutdown_timeout
        ),
    )
    signal.signal(
        signal.SIGTERM,
        lambda signum, frame: enhanced_signal_handler(
            signum, frame, args.shutdown_timeout
        ),
    )

    # Create a synchronous cleanup function for atexit
    def shutdown_resources_sync():
        """Synchronous resource cleanup for atexit."""
        try:
            # Shutdown thread pool executor
            api_executor.shutdown(wait=False)
            print("Thread pool executor shutdown completed")

            # Note: We can't close the database connection here because it's async
            # Database connections will be closed in the main function's finally block

        except Exception as e:
            print(f"Error during sync resource cleanup: {e}")

    # Register the synchronous cleanup function with atexit
    atexit.register(shutdown_resources_sync)

    # Configure logging
    configure_logging(log_file=args.log_file, log_level=args.log_level)

    # Update configuration
    update_config_from_args(args)

    # Generate a unique run ID
    run_id = f"run_{datetime.now().strftime('%Y%m%d%H%M%S')}_{uuid.uuid4().hex[:8]}"

    # Initialize stats
    crawl_stats = CrawlStats()

    # Initialize URL queue
    url_queue = UniqueURLQueue()

    # Set up signal handlers
    setup_signal_handlers()

    # Initialize database if enabled
    if Config.USE_SQLITE:
        try:
            await init_database()
            logger.info("Database initialized successfully")

            # Record crawl start
            university_name = (
                Config.SEED_UNIVERSITIES[0]["name"]
                if Config.SEED_UNIVERSITIES
                else "Unknown"
            )
            await start_crawl_run(run_id, university_name)

        except Exception as e:
            logger.error(f"Failed to initialize database: {e}")
            Config.USE_SQLITE = False

    logger.info(f"Starting crawler run {run_id}")
    logger.info(
        f"Targeting universities: {', '.join(u['name'] for u in Config.SEED_UNIVERSITIES)}"
    )

    # Initialize URL queue with seed URLs
    await prepare_url_queue(url_queue)

    # Initialize checkpoint manager if checkpoints are enabled
    checkpoint_manager = None
    if not args.disable_checkpoints:
        checkpoint_manager = CheckpointManager(
            run_id=run_id,
            output_dir=args.output_dir,
            checkpoint_interval=args.checkpoint_interval,
            min_batch_size=args.min_batch_size,
            max_batch_size=args.max_batch_size,
        )
        # Make checkpoint manager accessible via state manager for monitoring
        state_manager.checkpoint_manager = checkpoint_manager
        logger.info(
            f"Checkpointing enabled: interval={args.checkpoint_interval}s, batch size={args.min_batch_size}-{args.max_batch_size}"
        )
    else:
        logger.info("Checkpointing disabled - will process all pages at the end")

    # Setup for checkpoint processing
    async def process_checkpoint_batch():
        """Process a batch of pending application pages."""
        if not checkpoint_manager:
            return

        # Get a batch for processing
        batch = await checkpoint_manager.get_batch_for_processing()

        if not batch:
            logger.debug("No application pages to process in this batch")
            return

        logger.info(f"Processing checkpoint batch of {len(batch)} application pages")

        # Only evaluate if not skipping evaluation
        if not args.skip_evaluation:
            try:
                # Evaluate the batch
                evaluated_batch = await evaluate_all_applications(batch)

                # Store results
                await checkpoint_manager.add_evaluated_applications(evaluated_batch)

                # Save to database if enabled
                if Config.USE_SQLITE:
                    await save_application_pages(evaluated_batch, run_id)

                actual_count = sum(
                    1
                    for app in evaluated_batch
                    if app.get("is_actual_application", False)
                )
                logger.success(
                    f"Checkpoint: Identified {actual_count} actual application pages out of {len(evaluated_batch)} candidates"
                )

                # Save crawler state
                await checkpoint_manager.save_crawler_state(state_manager)

            except Exception as e:
                logger.error(f"Error processing checkpoint batch: {e}")
        else:
            # If skipping evaluation, just store the batch
            await checkpoint_manager.add_evaluated_applications(batch)
            logger.info(
                f"Checkpoint: Stored {len(batch)} unevaluated application pages (evaluation skipped)"
            )

    # Override add_application_page to use checkpointing
    if checkpoint_manager:
        original_add_application_page = state_manager.add_application_page

        async def add_application_page_with_checkpoint(page):
            """
            Wrapper for state_manager.add_application_page that also adds to checkpoint manager.
            """
            # Call the original method
            await original_add_application_page(page)

            # Add to checkpoint manager
            should_process = await checkpoint_manager.add_application_page(page)

            # If we should process a batch, do it now
            if should_process:
                await process_checkpoint_batch()

        # Replace the original method
        state_manager.add_application_page = add_application_page_with_checkpoint

    try:
        # Start crawler
        async with aiohttp.ClientSession() as session:
            # Start monitor task
            monitor_task = asyncio.create_task(monitor_progress(url_queue))

            # Start workers
            workers = await start_workers(session, url_queue, Config.NUM_WORKERS)

            try:
                # Wait for queue to be empty or max URLs to be reached
                while await state_manager.is_crawler_running():
                    if await check_for_shutdown() or _force_exit_event.is_set():
                        state_manager.stop_crawler()
                        break

                    if url_queue.empty():
                        logger.info("Queue is empty, crawling complete")
                        break

                    # Check URL limit
                    counters = await state_manager.get_counters()
                    if counters["visited"] >= Config.MAX_TOTAL_URLS:
                        logger.info(
                            f"Reached maximum total URLs limit ({Config.MAX_TOTAL_URLS})"
                        )
                        await state_manager.stop_crawler()
                        break

                    # Check for pending application pages that should be processed
                    if (
                        checkpoint_manager
                        and await checkpoint_manager.should_process_batch()
                    ):
                        await process_checkpoint_batch()

                    # Periodically save crawler state if checkpointing is enabled
                    if checkpoint_manager:
                        await checkpoint_manager.save_crawler_state(state_manager)

                    await asyncio.sleep(1)

                logger.info("Crawler reached completion criteria")

                # Process any remaining pending applications if checkpointing is enabled
                if checkpoint_manager:
                    await process_checkpoint_batch()

                # Give workers time to finish current tasks with timeout
                try:
                    await asyncio.wait_for(url_queue.join(), timeout=5)
                    logger.info("Queue joined successfully")
                except asyncio.TimeoutError:
                    logger.warning("Timeout waiting for queue to empty")

            except asyncio.CancelledError:
                logger.info("Crawler task cancelled")
            except Exception as e:
                logger.error(f"Error in main crawl loop: {e}")
            finally:
                # Request workers to stop
                await state_manager.stop_crawler()

                # Cancel workers and monitor with a timeout
                for w in workers:
                    w.cancel()

                monitor_task.cancel()

                # Wait for cancellation to complete with timeout
                try:
                    await asyncio.wait_for(
                        asyncio.gather(*workers, monitor_task, return_exceptions=True),
                        timeout=10,
                    )
                    logger.info("All tasks cancelled successfully")
                except asyncio.TimeoutError:
                    logger.warning("Timeout waiting for tasks to cancel")

            # Explore specific application paths if admission domains were found
            admission_domains = await state_manager.get_admission_domains()
            if admission_domains and not _force_exit_event.is_set():
                logger.info(
                    "Exploring specific application paths on admission domains..."
                )
                try:
                    await asyncio.wait_for(
                        explore_specific_application_paths(), timeout=30
                    )
                except asyncio.TimeoutError:
                    logger.warning("Timeout exploring application paths")

            # Get all evaluated applications if checkpointing was used
            evaluated_results = []
            if checkpoint_manager:
                logger.info("Retrieving evaluated applications from checkpoints")
                evaluated_results = checkpoint_manager.get_all_evaluated_applications()
                if evaluated_results:
                    logger.info(
                        f"Retrieved {len(evaluated_results)} evaluated applications from checkpoints"
                    )

            # Process any remaining application pages
            found_applications = await state_manager.get_application_pages()
            # Remove any that have already been evaluated through checkpoints
            if evaluated_results and found_applications:
                evaluated_urls = {app.get("url") for app in evaluated_results}
                remaining_applications = [
                    app
                    for app in found_applications
                    if app.get("url") not in evaluated_urls
                ]
                logger.info(
                    f"Found {len(found_applications)} total application pages, {len(remaining_applications)} not yet evaluated"
                )
                found_applications = remaining_applications

            if (
                found_applications
                and not evaluated_results
                and not _force_exit_event.is_set()
            ):
                logger.info(
                    f"Found {len(found_applications)} potential application pages"
                )

                if not args.skip_evaluation:
                    try:
                        # Process with timeout
                        try:
                            evaluated_results = await asyncio.wait_for(
                                evaluate_all_applications(found_applications),
                                timeout=60,  # 1 minute timeout
                            )
                        except asyncio.TimeoutError:
                            logger.error(
                                "Timeout during evaluation, proceeding with partial results"
                            )
                            evaluated_results = found_applications

                        if evaluated_results:
                            actual_count = sum(
                                1
                                for app in evaluated_results
                                if app.get("is_actual_application", False)
                            )
                            logger.success(
                                f"Identified {actual_count} actual application pages out of {len(evaluated_results)} candidates"
                            )

                            # Save to database if enabled
                            if Config.USE_SQLITE:
                                await save_application_pages(evaluated_results, run_id)

                                # Save API metrics
                                api_metrics = get_api_metrics()
                                await save_metrics_to_db(api_metrics, run_id)
                    except Exception as e:
                        logger.error(f"Error during evaluation: {e}")
                else:
                    logger.info("Skipping AI evaluation as requested")
                    evaluated_results = found_applications
            elif not found_applications and not evaluated_results:
                logger.warning("No application pages found")

            # Save results
            try:
                os.makedirs(args.output_dir, exist_ok=True)

                # Use all application pages for original file
                all_found_applications = await state_manager.get_application_pages()

                original_file, evaluated_file, summary_file = save_results(
                    all_found_applications,
                    evaluated_results if evaluated_results else None,
                    get_api_metrics() if not args.skip_evaluation else None,
                    output_dir=args.output_dir,
                )

                logger.success(f"Results saved to {args.output_dir}")

                # Generate "How to Apply" report
                if evaluated_results and not _force_exit_event.is_set():
                    try:
                        from output.how_to_apply_report import (
                            generate_how_to_apply_report,
                            export_how_to_apply_csv,
                        )

                        md_file = os.path.join(
                            args.output_dir,
                            f"how_to_apply_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md",
                        )
                        csv_file = os.path.join(
                            args.output_dir,
                            f"how_to_apply_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                        )
                        generate_how_to_apply_report(
                            evaluated_results, md_file, detailed=True
                        )
                        export_how_to_apply_csv(evaluated_results, csv_file)
                        logger.success(f"How to Apply report generated: {md_file}")
                        logger.success(f"How to Apply CSV generated: {csv_file}")
                    except Exception as e:
                        logger.error(f"Error generating How to Apply report: {e}")

                # Generate HTML report if requested
                if (
                    args.html_report
                    and evaluated_results
                    and not _force_exit_event.is_set()
                ):
                    try:
                        report_generator = ReportGenerator(
                            output_dir=os.path.join(args.output_dir, "reports")
                        )
                        report_file = await report_generator.generate_full_report(
                            evaluated_results,
                            crawl_stats.__dict__,
                            get_api_metrics() if not args.skip_evaluation else None,
                        )
                        logger.success(f"HTML report generated: {report_file}")
                    except Exception as e:
                        logger.error(f"Error generating HTML report: {e}")

                # Export to CSV if requested
                if args.csv and evaluated_results and not _force_exit_event.is_set():
                    try:
                        from output.exporter import export_to_csv

                        csv_file = os.path.join(
                            args.output_dir,
                            f"applications_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                        )
                        export_to_csv(evaluated_results, csv_file)
                        logger.success(f"CSV export generated: {csv_file}")
                    except Exception as e:
                        logger.error(f"Error exporting to CSV: {e}")

            except Exception as e:
                logger.error(f"Error saving results: {e}")

            # Update database with final stats if enabled
            if Config.USE_SQLITE and not _force_exit_event.is_set():
                try:
                    counters = await state_manager.get_counters()
                    await end_crawl_run(
                        run_id,
                        counters["visited"],
                        (
                            len(all_found_applications)
                            if "all_found_applications" in locals()
                            else 0
                        ),
                        (
                            len(
                                [
                                    a
                                    for a in evaluated_results
                                    if a.get("is_actual_application", False)
                                ]
                            )
                            if evaluated_results
                            else 0
                        ),
                    )
                except Exception as e:
                    logger.error(f"Error updating database with final stats: {e}")

    except Exception as e:
        logger.error(f"Unhandled exception in main: {e}")
    finally:
        # Final cleanup
        try:
            # Close the database connection
            if Config.USE_SQLITE:
                await close_connection()
                logger.info("Database connection closed")

            # Shutdown the thread pool executor
            api_executor.shutdown(wait=False)
            logger.info("Thread pool executor shutdown requested")

        except Exception as e:
            logger.error(f"Error during cleanup: {e}")

        logger.success(f"Crawler run {run_id} completed")


if __name__ == "__main__":
    try:
        asyncio.run(main())
        # If we've reached here, the program has exited normally
        logger.info("Program finished gracefully")

    except KeyboardInterrupt:
        print("\nProgram stopped by user")
        # Force exit after keyboard interrupt to ensure termination
        if not _force_exit_event.is_set():
            print("Forcing program termination...")
            os._exit(0)
    except Exception as e:
        print(f"Unhandled exception: {e}")
        sys.exit(1)



================================================
File: results.csv
================================================
filename,university,url
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/find-out-more/getting-here?ucam-ref=home-firstug
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/international-students?ucam-ref=home-firstug
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/colleges/choosing-a-college?ucam-ref=home-firstug
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk?ucam-ref=homepage-signpost
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses?ucam-ref=homepage-signpost
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=global-footer
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses?ucam-ref=home-firstug
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=home-menu
application_pages_20250315_173633.json,University of Cambridge,https://www.postgraduate.study.cam.ac.uk/application-process/how-do-i-apply?ucam-ref=home-action
application_pages_20250315_173633.json,University of Cambridge,https://www.postgraduate.study.cam.ac.uk/application-process/how-do-i-apply?ucam-ref=home-firstpg
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/applying?ucam-ref=home-action
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/applying?ucam-ref=home-firstug
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/new-undergraduate-students
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/ai-and-undergraduate-applications
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/second-undergraduate-degree
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/admissions-policy
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/application-decisions
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/application-outcomes
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/complaints
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/cambridge-interviews
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/college-assessments
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/apply-for-reconsideration
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/contextual-data
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/criminal-convictions
application_pages_20250315_173633.json,University of Cambridge,https://www.ucas.com/undergraduate/after-you-apply/types-offer/replying-your-ucas-undergraduate-offers
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/exam-results
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/interview-preparation
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses/medicine-mb-bchir%22%3EStandard%20Course%20%28A100%29%3C/a%3E%C2%A0and%20the%20%3Ca%20href%3D%22https%3A//www.undergraduate.study.cam.ac.uk/courses/medicine-graduate-course-mb-bchir%22%3EGraduate%20Course%20%28A101%29%3C/a%3E.%20If%20you%20choose%20to%20do%20so%2C%20you%20must%20apply%20to%20the%20same%20College%20for%20both%20courses.%20This%20means%20you%20could%20only%20apply%20to%20%3Ca%20href%3D%22https%3A//www.undergraduate.study.cam.ac.uk/colleges/lucy-cavendish-college
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/reconsideration-eligibility
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/sixth-term-exam-STEP
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/written-work-portfolio
application_pages_20250315_173633.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/applying/decisions/information-new-undergraduates
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/application-dates-deadlines
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/entry-requirements
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/accepted-qualifications
application_pages_20250315_173633.json,University of Cambridge,https://www.ucas.com/undergraduate/applying-university/individual-needs/ucas-undergraduate-care-experienced-students
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/choosing-high-school-subjects
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/improve-application
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/mature-student-applications
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/how/admission-tests
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/how/cambridge-application
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/how/law-admission-test
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/how/disrupted-studies
application_pages_20250315_173633.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/new-undergraduate-students
application_pages_20250315_173633.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/ai-and-undergraduate-applications
application_pages_20250315_173633.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/before/second-undergraduate-degree
application_pages_20250315_173633.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply
application_pages_20250315_173633.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/admissions-policy
application_pages_20250315_173633.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/application-outcomes
application_pages_20250315_173633.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/application-decisions
application_pages_20250315_173633.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/apply-for-reconsideration
application_pages_20250315_173633.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/cambridge-interviews
application_pages_20250315_173633.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/college-assessments
application_pages_20250315_173633.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/complaints
application_pages_20250315_173633.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/contextual-data
application_pages_20250315_173633.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/
application_pages_20250316_133722.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/
application_pages_20250316_133722.json,Stanford University,https://gradadmissions.stanford.edu/explore-programs
application_pages_20250316_133722.json,Stanford University,https://gradadmissions.stanford.edu/
application_pages_20250316_133722.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=global-footer
application_pages_20250316_133722.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply?ucam-ref=home-firstug
application_pages_20250316_133722.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply?ucam-ref=home-action
application_pages_20250316_133722.json,Stanford University,https://undergrad.stanford.edu/
application_pages_20250316_133722.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=home-menu
application_pages_20250316_133722.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=homepage-signpost
application_pages_20250316_133722.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/colleges/choosing-a-college?ucam-ref=home-firstug
application_pages_20250316_133722.json,UCL,https://www.ucl.ac.uk/
application_pages_20250316_133722.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/
application_pages_20250316_133722.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply
application_pages_20250316_133722.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/first-year
application_pages_20250316_133722.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/first-year/
application_pages_20250316_133722.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/freshman
application_pages_20250316_133722.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/freshman/
application_pages_20250316_133722.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/transfer
application_pages_20250316_133722.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/transfer/
application_pages_20250316_133722.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/
application_pages_20250316_133722.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/application
application_pages_20250316_133722.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/admission/apply
application_pages_20250316_133722.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/admission/first-year
application_pages_20250316_133722.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/admission/freshman
application_pages_20250315_163706.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=home-menu
application_pages_20250315_163706.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses?ucam-ref=home-firstug
application_pages_20250315_163706.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=global-footer
application_pages_20250315_163706.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/find-out-more/getting-here?ucam-ref=home-firstug
application_pages_20250315_163706.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/colleges/choosing-a-college?ucam-ref=home-firstug
application_pages_20250315_163706.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses?ucam-ref=homepage-signpost
application_pages_20250315_163706.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/applying?ucam-ref=home-action
application_pages_20250315_163706.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/applying?ucam-ref=home-firstug
application_pages_20250315_163706.json,Stanford University,https://gradadmissions.stanford.edu/explore-programs
application_pages_20250315_163706.json,Stanford University,https://gradadmissions.stanford.edu
application_pages_20250315_163706.json,Stanford University,https://undergrad.stanford.edu/
application_pages_20250315_163706.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/second-undergraduate-degree
application_pages_20250315_163706.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/ai-and-undergraduate-applications
application_pages_20250315_163706.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply
application_pages_20250315_163706.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/new-undergraduate-students
application_pages_20250315_163706.json,Stanford University,https://gradadmissions.stanford.edu/apply/application-fee
application_pages_20250315_163706.json,Stanford University,https://gradadmissions.stanford.edu/apply
application_pages_20250315_163706.json,Stanford University,https://applygrad.stanford.edu/portal/programs
application_pages_20250315_163706.json,Stanford University,https://gradadmissions.stanford.edu/apply/application-fee/gre-fee-reduction-waivers
application_pages_20250315_163706.json,Stanford University,https://gradadmissions.stanford.edu/apply/application-fee/program-participation-waivers
application_pages_20250315_163706.json,Stanford University,https://gradadmissions.stanford.edu/apply/application-fee/program-participation-waivers/eligible-programs
application_pages_20250315_163706.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses/medicine-mb-bchir%22%3EStandard%20Course%20%28A100%29%3C/a%3E%C2%A0and%20the%20%3Ca%20href%3D%22https%3A//www.undergraduate.study.cam.ac.uk/courses/medicine-graduate-course-mb-bchir%22%3EGraduate%20Course%20%28A101%29%3C/a%3E.%20If%20you%20choose%20to%20do%20so%2C%20you%20must%20apply%20to%20the%20same%20College%20for%20both%20courses.%20This%20means%20you%20could%20only%20apply%20to%20%3Ca%20href%3D%22https%3A//www.undergraduate.study.cam.ac.uk/colleges/lucy-cavendish-college
application_pages_20250315_163706.json,Stanford University,https://gradadmissions.stanford.edu/apply/application-overview
application_pages_20250315_163706.json,Stanford University,https://gradadmissions.stanford.edu/apply/application-fee/school-based-waivers
application_pages_20250315_163706.json,Stanford University,https://gradadmissions.stanford.edu/apply/apply-now
application_pages_20250315_163706.json,Stanford University,https://gradadmissions.stanford.edu/apply/dates-and-deadlines
application_pages_20250315_163706.json,Stanford University,https://gradadmissions.stanford.edu/apply/current-stanford-students
application_pages_20250315_163706.json,Stanford University,https://gradadmissions.stanford.edu/apply/eligibility
application_pages_20250315_163706.json,Stanford University,https://gradadmissions.stanford.edu/apply/faq
application_pages_20250315_163706.json,Stanford University,https://gradadmissions.stanford.edu/apply/recommendations
application_pages_20250315_163706.json,Stanford University,https://gradadmissions.stanford.edu/apply/statements
application_pages_20250315_163706.json,Stanford University,https://admission.stanford.edu/
application_pages_20250315_163706.json,Stanford University,https://admission.stanford.edu/apply/first-year
application_pages_20250315_163706.json,Stanford University,https://applygrad.stanford.edu/apply/status
application_pages_20250315_163706.json,Stanford University,https://gradadmissions.stanford.edu/apply/
application_pages_20250315_163706.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/
application_pages_20250315_163706.json,Stanford University,https://applygrad.stanford.edu/apply
application_pages_20250315_163706.json,Stanford University,https://applygrad.stanford.edu/apply/
application_pages_20250315_163706.json,Stanford University,https://admission.stanford.edu/apply/
application_pages_20250315_163706.json,Stanford University,https://admission.stanford.edu/apply/first-year/
application_pages_20250315_163706.json,Stanford University,https://admission.stanford.edu/apply/transfer
application_pages_20250315_163706.json,Stanford University,https://admission.stanford.edu/apply/transfer/
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses?ucam-ref=home-firstug
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses?ucam-ref=homepage-signpost
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=global-footer
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=home-menu
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/international-students?ucam-ref=home-firstug
application_pages_20250315_164305.json,University of Cambridge,https://www.postgraduate.study.cam.ac.uk/application-process/how-do-i-apply?ucam-ref=home-action
application_pages_20250315_164305.json,University of Cambridge,https://www.postgraduate.study.cam.ac.uk/application-process/how-do-i-apply?ucam-ref=home-firstpg
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/find-out-more/getting-here?ucam-ref=home-firstug
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/colleges/choosing-a-college?ucam-ref=home-firstug
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk?ucam-ref=homepage-signpost
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/second-undergraduate-degree
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/new-undergraduate-students
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/applying?ucam-ref=home-firstug
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/applying?ucam-ref=home-action
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/admissions-policy
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/application-decisions
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/ai-and-undergraduate-applications
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/application-outcomes
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses/medicine-mb-bchir%22%3EStandard%20Course%20%28A100%29%3C/a%3E%C2%A0and%20the%20%3Ca%20href%3D%22https%3A//www.undergraduate.study.cam.ac.uk/courses/medicine-graduate-course-mb-bchir%22%3EGraduate%20Course%20%28A101%29%3C/a%3E.%20If%20you%20choose%20to%20do%20so%2C%20you%20must%20apply%20to%20the%20same%20College%20for%20both%20courses.%20This%20means%20you%20could%20only%20apply%20to%20%3Ca%20href%3D%22https%3A//www.undergraduate.study.cam.ac.uk/colleges/lucy-cavendish-college
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/college-assessments
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/cambridge-interviews
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/apply-for-reconsideration
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/complaints
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/interview-preparation
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/exam-results
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/criminal-convictions
application_pages_20250315_164305.json,University of Cambridge,https://www.ucas.com/undergraduate/after-you-apply/types-offer/replying-your-ucas-undergraduate-offers
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/sixth-term-exam-STEP
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/accepted-qualifications
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/contextual-data
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/application-dates-deadlines
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/reconsideration-eligibility
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/written-work-portfolio
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/entry-requirements
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/improve-application
application_pages_20250315_164305.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/applying/decisions/information-new-undergraduates
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/choosing-high-school-subjects
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/mature-student-applications
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/how/admission-tests
application_pages_20250315_164305.json,University of Cambridge,https://www.ucas.com/undergraduate/applying-university/individual-needs/ucas-undergraduate-care-experienced-students
application_pages_20250315_164305.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/new-undergraduate-students
application_pages_20250315_164305.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/ai-and-undergraduate-applications
application_pages_20250315_164305.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/before/second-undergraduate-degree
application_pages_20250315_164305.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply
application_pages_20250315_164305.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/admissions-policy
application_pages_20250315_164305.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk?ucam-ref=homepage-signpost
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=global-footer
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/international-students?ucam-ref=home-firstug
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses?ucam-ref=homepage-signpost
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses?ucam-ref=home-firstug
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=home-menu
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/find-out-more/getting-here?ucam-ref=home-firstug
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/colleges/choosing-a-college?ucam-ref=home-firstug
application_pages_20250315_172239.json,University of Cambridge,https://www.postgraduate.study.cam.ac.uk/application-process/how-do-i-apply?ucam-ref=home-firstpg
application_pages_20250315_172239.json,University of Cambridge,https://www.postgraduate.study.cam.ac.uk/application-process/how-do-i-apply?ucam-ref=home-action
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/applying?ucam-ref=home-action
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/applying?ucam-ref=home-firstug
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/second-undergraduate-degree
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/new-undergraduate-students
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/ai-and-undergraduate-applications
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/admissions-policy
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/application-decisions
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/apply-for-reconsideration
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/application-outcomes
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses/medicine-mb-bchir%22%3EStandard%20Course%20%28A100%29%3C/a%3E%C2%A0and%20the%20%3Ca%20href%3D%22https%3A//www.undergraduate.study.cam.ac.uk/courses/medicine-graduate-course-mb-bchir%22%3EGraduate%20Course%20%28A101%29%3C/a%3E.%20If%20you%20choose%20to%20do%20so%2C%20you%20must%20apply%20to%20the%20same%20College%20for%20both%20courses.%20This%20means%20you%20could%20only%20apply%20to%20%3Ca%20href%3D%22https%3A//www.undergraduate.study.cam.ac.uk/colleges/lucy-cavendish-college
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/cambridge-interviews
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/college-assessments
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/complaints
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/criminal-convictions
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/interview-preparation
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/exam-results
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/contextual-data
application_pages_20250315_172239.json,University of Cambridge,https://www.ucas.com/undergraduate/after-you-apply/types-offer/replying-your-ucas-undergraduate-offers
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/reconsideration-eligibility
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/sixth-term-exam-STEP
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/written-work-portfolio
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/application-dates-deadlines
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/accepted-qualifications
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/choosing-high-school-subjects
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/entry-requirements
application_pages_20250315_172239.json,University of Cambridge,https://www.ucas.com/undergraduate/applying-university/individual-needs/ucas-undergraduate-care-experienced-students
application_pages_20250315_172239.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/applying/decisions/information-new-undergraduates
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/improve-application
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/mature-student-applications
application_pages_20250315_172239.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/new-undergraduate-students
application_pages_20250315_172239.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/ai-and-undergraduate-applications
application_pages_20250315_172239.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/before/second-undergraduate-degree
application_pages_20250315_172239.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply
application_pages_20250315_172239.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/admissions-policy
application_pages_20250315_172239.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/application-decisions
application_pages_20250315_172239.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/application-outcomes
application_pages_20250315_172239.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/apply-for-reconsideration
application_pages_20250315_172239.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/cambridge-interviews
application_pages_20250315_172239.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/college-assessments
application_pages_20250315_172239.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/complaints
application_pages_20250315_172239.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/contextual-data
application_pages_20250315_172239.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/criminal-convictions
application_pages_20250315_172239.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/exam-results
application_pages_20250315_172239.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/interview-preparation
application_pages_20250315_172239.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/reconsideration-eligibility
application_pages_20250315_172239.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/sixth-term-exam-STEP
application_pages_20250315_172239.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/written-work-portfolio
application_pages_20250315_172239.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/application-dates-deadlines
application_pages_20250315_172239.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/before/choosing-high-school-subjects
application_pages_20250315_172239.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/before/accepted-qualifications
application_pages_20250315_172239.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/
application_pages_20250316_015501.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=global-footer
application_pages_20250316_015501.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=home-menu
application_pages_20250316_015501.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/applying?ucam-ref=home-action
application_pages_20250316_015501.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/applying?ucam-ref=home-firstug
application_pages_20250316_015501.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/second-undergraduate-degree
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/
application_pages_20250316_015501.json,Stanford University,https://gradadmissions.stanford.edu/explore-programs
application_pages_20250316_015501.json,Stanford University,https://gradadmissions.stanford.edu
application_pages_20250316_015501.json,Stanford University,https://undergrad.stanford.edu/
application_pages_20250316_015501.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/new-undergraduate-students
application_pages_20250316_015501.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/ai-and-undergraduate-applications
application_pages_20250316_015501.json,UCL,https://www.ucl.ac.uk
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply-to-berkeley
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply-to-berkeley/application-resources/personal-insight-questions
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply-to-berkeley/application-resources/application-tips
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply-to-berkeley/application-resources
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply-to-berkeley/dates-deadlines
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply-to-berkeley/application-resources/selection-process
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply-to-berkeley/counselors-colleagues
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply-to-berkeley/freshmen
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply-to-berkeley/freshmen/freshman-policy-changes
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply-to-berkeley/freshmen/freshmen-requirements
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply-to-berkeley/international-students
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply-to-berkeley/freshmen/applicant-checklist
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply-to-berkeley/student-profile
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply-to-berkeley/transfer-students
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply-to-berkeley/transfer-students/transfer-applicant-checklist
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply-to-berkeley/transfer-students/transfer-requirements
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply-to-berkeley/transfer-students/transfer-resources
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply-to-berkeley/veterans
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/cost/apply-for-financial-aid
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/first-year
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/first-year/
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/freshman
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/freshman/
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/transfer
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/transfer/
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/application
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/admission/apply
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/admission/first-year
application_pages_20250316_015501.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/admission/freshman
application_pages_20250316_015501.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/
application_pages_20250316_015501.json,Stanford University,https://gradadmissions.stanford.edu/apply/
application_pages_20250316_110959.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=home-menu
application_pages_20250316_110959.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/
application_pages_20250316_110959.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply?ucam-ref=home-action
application_pages_20250316_110959.json,Stanford University,https://gradadmissions.stanford.edu/explore-programs
application_pages_20250316_110959.json,Stanford University,https://gradadmissions.stanford.edu/
application_pages_20250316_110959.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=homepage-signpost
application_pages_20250316_110959.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=global-footer
application_pages_20250316_110959.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply?ucam-ref=home-firstug
application_pages_20250316_110959.json,Stanford University,https://undergrad.stanford.edu/
application_pages_20250316_110959.json,UCL,https://www.ucl.ac.uk/
application_pages_20250316_110959.json,Stanford University,https://admission.stanford.edu/
application_pages_20250316_110959.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/colleges/choosing-a-college?ucam-ref=home-firstug
application_pages_20250316_110959.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/new-undergraduate-students
application_pages_20250316_110959.json,Stanford University,https://gradadmissions.stanford.edu/apply/
application_pages_20250316_110959.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/
application_pages_20250316_110959.json,Stanford University,https://admission.stanford.edu/apply/
application_pages_20250316_110959.json,Stanford University,https://admission.stanford.edu/apply/first-year/
application_pages_20250316_110959.json,Stanford University,https://admission.stanford.edu/apply/transfer
application_pages_20250316_110959.json,Stanford University,https://admission.stanford.edu/apply/transfer/
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/find-out-more/getting-here?ucam-ref=home-firstug
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/colleges/choosing-a-college?ucam-ref=home-firstug
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses?ucam-ref=home-firstug
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/international-students?ucam-ref=home-firstug
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=home-menu
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=global-footer
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk?ucam-ref=homepage-signpost
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses?ucam-ref=homepage-signpost
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/applying?ucam-ref=home-firstug
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/applying?ucam-ref=home-action
application_pages_20250315_171703.json,University of Cambridge,https://www.postgraduate.study.cam.ac.uk/application-process/how-do-i-apply?ucam-ref=home-action
application_pages_20250315_171703.json,University of Cambridge,https://www.postgraduate.study.cam.ac.uk/application-process/how-do-i-apply?ucam-ref=home-firstpg
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/new-undergraduate-students
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/ai-and-undergraduate-applications
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/application-decisions
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/admissions-policy
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/second-undergraduate-degree
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/application-outcomes
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/apply-for-reconsideration
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/college-assessments
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/complaints
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/cambridge-interviews
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/contextual-data
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/exam-results
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses/medicine-mb-bchir%22%3EStandard%20Course%20%28A100%29%3C/a%3E%C2%A0and%20the%20%3Ca%20href%3D%22https%3A//www.undergraduate.study.cam.ac.uk/courses/medicine-graduate-course-mb-bchir%22%3EGraduate%20Course%20%28A101%29%3C/a%3E.%20If%20you%20choose%20to%20do%20so%2C%20you%20must%20apply%20to%20the%20same%20College%20for%20both%20courses.%20This%20means%20you%20could%20only%20apply%20to%20%3Ca%20href%3D%22https%3A//www.undergraduate.study.cam.ac.uk/colleges/lucy-cavendish-college
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/criminal-convictions
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/reconsideration-eligibility
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/interview-preparation
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/sixth-term-exam-STEP
application_pages_20250315_171703.json,University of Cambridge,https://www.ucas.com/undergraduate/after-you-apply/types-offer/replying-your-ucas-undergraduate-offers
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/written-work-portfolio
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/application-dates-deadlines
application_pages_20250315_171703.json,University of Cambridge,https://www.ucas.com/undergraduate/applying-university/individual-needs/ucas-undergraduate-care-experienced-students
application_pages_20250315_171703.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/applying/decisions/information-new-undergraduates
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/accepted-qualifications
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/choosing-high-school-subjects
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/entry-requirements
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/improve-application
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/mature-student-applications
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/how/admission-tests
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/how/cambridge-application
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/how/law-admission-test
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/how/disrupted-studies
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/how/maths-admission-test
application_pages_20250315_171703.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/new-undergraduate-students
application_pages_20250315_171703.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/ai-and-undergraduate-applications
application_pages_20250315_171703.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/before/second-undergraduate-degree
application_pages_20250315_171703.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply
application_pages_20250315_171703.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/admissions-policy
application_pages_20250315_171703.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/application-decisions
application_pages_20250315_171703.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/application-outcomes
application_pages_20250315_171703.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/apply-for-reconsideration
application_pages_20250315_171703.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/cambridge-interviews
application_pages_20250315_171703.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/college-assessments
application_pages_20250315_171703.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/complaints
application_pages_20250315_171703.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/contextual-data
application_pages_20250315_171703.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/criminal-convictions
application_pages_20250315_171703.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/exam-results
application_pages_20250315_171703.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/reconsideration-eligibility
application_pages_20250315_171703.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/interview-preparation
application_pages_20250315_171703.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/sixth-term-exam-STEP
application_pages_20250315_171703.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/written-work-portfolio
application_pages_20250315_171703.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/application-dates-deadlines
application_pages_20250315_171703.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/before/accepted-qualifications
application_pages_20250315_171703.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/before/choosing-high-school-subjects
application_pages_20250315_171703.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/
application_pages_20250316_104021.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/
application_pages_20250316_104021.json,"University of California, Berkeley (UCB)",https://bconnected.berkeley.edu/
application_pages_20250316_104021.json,"University of California, Berkeley (UCB)",https://financialaid.berkeley.edu/apply-now/apply-for-aid
application_pages_20250316_104021.json,"University of California, Berkeley (UCB)",https://guide.berkeley.edu/undergraduate
application_pages_20250316_104021.json,"University of California, Berkeley (UCB)",https://admission.universityofcalifornia.edu/tuition-financial-aid/tuition-cost-of-attendance/ab-540-nonresident-tuition-exemption.html
application_pages_20250316_104021.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply
application_pages_20250316_104021.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/first-year
application_pages_20250316_104021.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/first-year/
application_pages_20250316_104021.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/freshman
application_pages_20250316_104021.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/freshman/
application_pages_20250316_104021.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/transfer
application_pages_20250316_104021.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/transfer/
application_pages_20250316_104021.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/
application_pages_20250316_104021.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/application
application_pages_20250316_104021.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/admission/apply
application_pages_20250316_104021.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/admission/first-year
application_pages_20250316_104021.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/admission/freshman
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk?ucam-ref=homepage-signpost
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/colleges/choosing-a-college?ucam-ref=home-firstug
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/find-out-more/getting-here?ucam-ref=home-firstug
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses?ucam-ref=homepage-signpost
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=home-menu
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/international-students?ucam-ref=home-firstug
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses?ucam-ref=home-firstug
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=global-footer
application_pages_20250315_171320.json,University of Cambridge,https://www.postgraduate.study.cam.ac.uk/application-process/how-do-i-apply?ucam-ref=home-action
application_pages_20250315_171320.json,University of Cambridge,https://www.postgraduate.study.cam.ac.uk/application-process/how-do-i-apply?ucam-ref=home-firstpg
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/applying?ucam-ref=home-firstug
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/applying?ucam-ref=home-action
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/new-undergraduate-students
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/second-undergraduate-degree
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/ai-and-undergraduate-applications
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/admissions-policy
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/application-decisions
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/apply-for-reconsideration
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/application-outcomes
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/cambridge-interviews
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/contextual-data
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/complaints
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/criminal-convictions
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/college-assessments
application_pages_20250315_171320.json,University of Cambridge,https://www.ucas.com/undergraduate/after-you-apply/types-offer/replying-your-ucas-undergraduate-offers
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/exam-results
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/interview-preparation
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/reconsideration-eligibility
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses/medicine-mb-bchir%22%3EStandard%20Course%20%28A100%29%3C/a%3E%C2%A0and%20the%20%3Ca%20href%3D%22https%3A//www.undergraduate.study.cam.ac.uk/courses/medicine-graduate-course-mb-bchir%22%3EGraduate%20Course%20%28A101%29%3C/a%3E.%20If%20you%20choose%20to%20do%20so%2C%20you%20must%20apply%20to%20the%20same%20College%20for%20both%20courses.%20This%20means%20you%20could%20only%20apply%20to%20%3Ca%20href%3D%22https%3A//www.undergraduate.study.cam.ac.uk/colleges/lucy-cavendish-college
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/sixth-term-exam-STEP
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/written-work-portfolio
application_pages_20250315_171320.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/applying/decisions/information-new-undergraduates
application_pages_20250315_171320.json,University of Cambridge,https://www.ucas.com/undergraduate/applying-university/individual-needs/ucas-undergraduate-care-experienced-students
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/accepted-qualifications
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/choosing-high-school-subjects
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/application-dates-deadlines
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/entry-requirements
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/mature-student-applications
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/improve-application
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/how/admission-tests
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/how/cambridge-application
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/how/disrupted-studies
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/how/law-admission-test
application_pages_20250315_171320.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/new-undergraduate-students
application_pages_20250315_171320.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/ai-and-undergraduate-applications
application_pages_20250315_171320.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/before/second-undergraduate-degree
application_pages_20250315_171320.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply
application_pages_20250315_171320.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/admissions-policy
application_pages_20250315_171320.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/application-decisions
application_pages_20250315_171320.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/application-outcomes
application_pages_20250315_171320.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/cambridge-interviews
application_pages_20250315_171320.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/college-assessments
application_pages_20250315_171320.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/apply-for-reconsideration
application_pages_20250315_171320.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/complaints
application_pages_20250315_171320.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/criminal-convictions
application_pages_20250315_171320.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/exam-results
application_pages_20250315_171320.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/contextual-data
application_pages_20250315_171320.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/
application_pages_20250316_111228.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=global-footer
application_pages_20250316_111228.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=home-menu
application_pages_20250316_111228.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=homepage-signpost
application_pages_20250316_111228.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply?ucam-ref=home-firstug
application_pages_20250316_111228.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply?ucam-ref=home-action
application_pages_20250316_111228.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/
application_pages_20250316_111228.json,Stanford University,https://gradadmissions.stanford.edu/
application_pages_20250316_111228.json,Stanford University,https://gradadmissions.stanford.edu/explore-programs
application_pages_20250316_111228.json,Stanford University,https://undergrad.stanford.edu/
application_pages_20250316_111228.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/new-undergraduate-students
application_pages_20250316_111228.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/second-undergraduate-degree
application_pages_20250316_111228.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/ai-and-undergraduate-applications
application_pages_20250316_111228.json,UCL,https://www.ucl.ac.uk/
application_pages_20250316_111228.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/
application_pages_20250316_111228.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply
application_pages_20250316_111228.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/first-year
application_pages_20250316_111228.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/first-year/
application_pages_20250316_111228.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/freshman
application_pages_20250316_111228.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/freshman/
application_pages_20250316_111228.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/transfer
application_pages_20250316_111228.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/transfer/
application_pages_20250316_111228.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/
application_pages_20250316_111228.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/application
application_pages_20250316_111228.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/admission/apply
application_pages_20250316_111228.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/admission/first-year
application_pages_20250316_111228.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/admission/freshman
application_pages_20250316_111228.json,Stanford University,https://gradadmissions.stanford.edu/apply/
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk?ucam-ref=homepage-signpost
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/colleges/choosing-a-college?ucam-ref=home-firstug
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/find-out-more/getting-here?ucam-ref=home-firstug
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/international-students?ucam-ref=home-firstug
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=home-menu
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses?ucam-ref=homepage-signpost
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=global-footer
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/applying?ucam-ref=home-action
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/applying?ucam-ref=home-firstug
application_pages_20250315_165527.json,University of Cambridge,https://www.postgraduate.study.cam.ac.uk/application-process/how-do-i-apply?ucam-ref=home-firstpg
application_pages_20250315_165527.json,University of Cambridge,https://www.postgraduate.study.cam.ac.uk/application-process/how-do-i-apply?ucam-ref=home-action
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/new-undergraduate-students
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses?ucam-ref=home-firstug
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/ai-and-undergraduate-applications
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/second-undergraduate-degree
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/admissions-policy
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/application-decisions
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/application-outcomes
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/apply-for-reconsideration
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/cambridge-interviews
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/contextual-data
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/college-assessments
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/complaints
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/criminal-convictions
application_pages_20250315_165527.json,University of Cambridge,https://www.ucas.com/undergraduate/after-you-apply/types-offer/replying-your-ucas-undergraduate-offers
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/exam-results
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/reconsideration-eligibility
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/interview-preparation
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses/medicine-mb-bchir%22%3EStandard%20Course%20%28A100%29%3C/a%3E%C2%A0and%20the%20%3Ca%20href%3D%22https%3A//www.undergraduate.study.cam.ac.uk/courses/medicine-graduate-course-mb-bchir%22%3EGraduate%20Course%20%28A101%29%3C/a%3E.%20If%20you%20choose%20to%20do%20so%2C%20you%20must%20apply%20to%20the%20same%20College%20for%20both%20courses.%20This%20means%20you%20could%20only%20apply%20to%20%3Ca%20href%3D%22https%3A//www.undergraduate.study.cam.ac.uk/colleges/lucy-cavendish-college
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/sixth-term-exam-STEP
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/written-work-portfolio
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/choosing-high-school-subjects
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/accepted-qualifications
application_pages_20250315_165527.json,University of Cambridge,https://www.ucas.com/undergraduate/applying-university/individual-needs/ucas-undergraduate-care-experienced-students
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/application-dates-deadlines
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/entry-requirements
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/improve-application
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/mature-student-applications
application_pages_20250315_165527.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/applying/decisions/information-new-undergraduates
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/how/cambridge-application
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/how/admission-tests
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/how/disrupted-studies
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/how/law-admission-test
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/how/maths-admission-test
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/how/medicine-admission-test
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/how/transcript
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/how/science-engineering-admission-test
application_pages_20250315_165527.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/new-undergraduate-students
application_pages_20250315_165527.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/ai-and-undergraduate-applications
application_pages_20250315_165527.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/before/second-undergraduate-degree
application_pages_20250315_165527.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply
application_pages_20250315_165527.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/admissions-policy
application_pages_20250315_165527.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/application-decisions
application_pages_20250315_165527.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/application-outcomes
application_pages_20250315_165527.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/
application_pages_20250314_201528.json,Stanford,https://www.stanford.edu/admission
application_pages_20250314_201528.json,Stanford,https://undergrad.stanford.edu/
application_pages_20250314_201528.json,Stanford,https://gradadmissions.stanford.edu
application_pages_20250314_201528.json,Stanford,https://gradadmissions.stanford.edu/explore-programs
application_pages_20250314_201528.json,Stanford,https://admission.stanford.edu/
application_pages_20250314_201528.json,Stanford,https://gradadmissions.stanford.edu/apply
application_pages_20250314_201528.json,Stanford,https://undergrad.stanford.edu/programs/bhc/apply
application_pages_20250314_201528.json,Stanford,https://undergrad.stanford.edu/programs/bhc/apply/contact-your-department
application_pages_20250314_201528.json,Stanford,http://facultypositions.stanford.edu/
application_pages_20250314_201528.json,Stanford,https://gradadmissions.stanford.edu/apply/application-fee
application_pages_20250314_201528.json,Stanford,https://admission.stanford.edu/apply/first-year
application_pages_20250314_201528.json,Stanford,https://applygrad.stanford.edu/portal/programs
application_pages_20250314_201528.json,Stanford,https://admission.stanford.edu/apply/overview/index.html
application_pages_20250314_201528.json,Stanford,https://events.stanford.edu/event/2025-first-year-mfa-exhibition
application_pages_20250314_201528.json,Stanford,https://gradadmissions.stanford.edu/apply/application-fee/gre-fee-reduction-waivers
application_pages_20250314_201528.json,Stanford,https://admission.stanford.edu/apply
application_pages_20250314_201528.json,Stanford,https://apply.stanford.edu/portal/virtual-visits
application_pages_20250314_201528.json,Stanford,https://apply.stanford.edu/portal/admission-events
application_pages_20250314_201528.json,Stanford,https://gradadmissions.stanford.edu/apply/application-fee/program-participation-waivers
application_pages_20250314_201528.json,Stanford,https://gradadmissions.stanford.edu/apply/application-fee/program-participation-waivers/eligible-programs
application_pages_20250314_201528.json,Stanford,https://admission.stanford.edu/apply/first-year/submitted.html
application_pages_20250314_201528.json,Stanford,https://admission.stanford.edu/apply/apply.html
application_pages_20250314_201528.json,Stanford,"https://financialaid.stanford.edu/"" target=""_blank"">FAO website</a> for announcements or contact them at <a href=""http://financialaid.stanford.edu/contact"" target=""_blank"">FAO-Contact Us</a>.</p></p><h3>Stanford will resume standardized test requirement for undergraduate admission</h3><p>Stanford will resume requiring either the SAT or the ACT for undergraduate admission, beginning with students applying in fall 2025 for admission to the Class of 2030. Stanford will remain test-optional for students applying in fall 2024 for admission to the Class of 2029.<br><a href="
application_pages_20250314_201528.json,Stanford,https://gradadmissions.stanford.edu/apply/
application_pages_20250314_201528.json,Stanford,https://apply.stanford.edu/apply
application_pages_20250314_201528.json,Stanford,https://apply.stanford.edu/apply/
application_pages_20250314_201528.json,Stanford,https://admission.stanford.edu/apply/
application_pages_20250314_201528.json,Stanford,https://admission.stanford.edu/apply/first-year/
application_pages_20250314_201528.json,Stanford,https://admission.stanford.edu/apply/transfer
application_pages_20250314_201528.json,Stanford,https://admission.stanford.edu/apply/transfer/
application_pages_20250314_201528.json,Stanford,https://applygrad.stanford.edu/apply
application_pages_20250314_201528.json,Stanford,https://applygrad.stanford.edu/apply/
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=global-footer
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk?ucam-ref=homepage-signpost
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses?ucam-ref=homepage-signpost
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/find-out-more/getting-here?ucam-ref=home-firstug
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=home-menu
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/colleges/choosing-a-college?ucam-ref=home-firstug
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses?ucam-ref=home-firstug
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/international-students?ucam-ref=home-firstug
application_pages_20250315_172447.json,University of Cambridge,https://www.postgraduate.study.cam.ac.uk/application-process/how-do-i-apply?ucam-ref=home-action
application_pages_20250315_172447.json,University of Cambridge,https://www.postgraduate.study.cam.ac.uk/application-process/how-do-i-apply?ucam-ref=home-firstpg
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/applying?ucam-ref=home-firstug
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/applying?ucam-ref=home-action
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/new-undergraduate-students
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/second-undergraduate-degree
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/ai-and-undergraduate-applications
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/application-decisions
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/admissions-policy
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/application-outcomes
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/cambridge-interviews
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses/medicine-mb-bchir%22%3EStandard%20Course%20%28A100%29%3C/a%3E%C2%A0and%20the%20%3Ca%20href%3D%22https%3A//www.undergraduate.study.cam.ac.uk/courses/medicine-graduate-course-mb-bchir%22%3EGraduate%20Course%20%28A101%29%3C/a%3E.%20If%20you%20choose%20to%20do%20so%2C%20you%20must%20apply%20to%20the%20same%20College%20for%20both%20courses.%20This%20means%20you%20could%20only%20apply%20to%20%3Ca%20href%3D%22https%3A//www.undergraduate.study.cam.ac.uk/colleges/lucy-cavendish-college
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/apply-for-reconsideration
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/college-assessments
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/complaints
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/interview-preparation
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/contextual-data
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/criminal-convictions
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/exam-results
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/reconsideration-eligibility
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/sixth-term-exam-STEP
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/written-work-portfolio
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/application-dates-deadlines
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/accepted-qualifications
application_pages_20250315_172447.json,University of Cambridge,https://www.ucas.com/undergraduate/after-you-apply/types-offer/replying-your-ucas-undergraduate-offers
application_pages_20250315_172447.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/applying/decisions/information-new-undergraduates
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/choosing-high-school-subjects
application_pages_20250315_172447.json,University of Cambridge,https://www.ucas.com/undergraduate/applying-university/individual-needs/ucas-undergraduate-care-experienced-students
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/mature-student-applications
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/how/cambridge-application
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/how/admission-tests
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/improve-application
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/entry-requirements
application_pages_20250315_172447.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/new-undergraduate-students
application_pages_20250315_172447.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/ai-and-undergraduate-applications
application_pages_20250315_172447.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/before/second-undergraduate-degree
application_pages_20250315_172447.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply
application_pages_20250315_172447.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/admissions-policy
application_pages_20250315_172447.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/application-decisions
application_pages_20250315_172447.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/application-outcomes
application_pages_20250315_172447.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/apply-for-reconsideration
application_pages_20250315_172447.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/cambridge-interviews
application_pages_20250315_172447.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/college-assessments
application_pages_20250315_172447.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/complaints
application_pages_20250315_172447.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/contextual-data
application_pages_20250315_172447.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/criminal-convictions
application_pages_20250315_172447.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/exam-results
application_pages_20250315_172447.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/interview-preparation
application_pages_20250315_172447.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/reconsideration-eligibility
application_pages_20250315_172447.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/sixth-term-exam-STEP
application_pages_20250315_172447.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/written-work-portfolio
application_pages_20250315_172447.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/application-dates-deadlines
application_pages_20250315_172447.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/before/accepted-qualifications
application_pages_20250315_172447.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/before/choosing-high-school-subjects
application_pages_20250315_172447.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses?ucam-ref=homepage-signpost
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk?ucam-ref=homepage-signpost
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=home-menu
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/international-students?ucam-ref=home-firstug
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/find-out-more/getting-here?ucam-ref=home-firstug
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=global-footer
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses?ucam-ref=home-firstug
application_pages_20250316_012631.json,University of Cambridge,https://www.postgraduate.study.cam.ac.uk/application-process/how-do-i-apply?ucam-ref=home-action
application_pages_20250316_012631.json,University of Cambridge,https://www.postgraduate.study.cam.ac.uk/application-process/how-do-i-apply?ucam-ref=home-firstpg
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/applying?ucam-ref=home-action
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/applying?ucam-ref=home-firstug
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/colleges/choosing-a-college?ucam-ref=home-firstug
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/second-undergraduate-degree
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/application-decisions
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/ai-and-undergraduate-applications
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/admissions-policy
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/new-undergraduate-students
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/application-outcomes
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/college-assessments
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/cambridge-interviews
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/apply-for-reconsideration
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/complaints
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/contextual-data
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/criminal-convictions
application_pages_20250316_012631.json,University of Cambridge,https://www.ucas.com/undergraduate/after-you-apply/types-offer/replying-your-ucas-undergraduate-offers
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/exam-results
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses/medicine-mb-bchir%22%3EStandard%20Course%20%28A100%29%3C/a%3E%C2%A0and%20the%20%3Ca%20href%3D%22https%3A//www.undergraduate.study.cam.ac.uk/courses/medicine-graduate-course-mb-bchir%22%3EGraduate%20Course%20%28A101%29%3C/a%3E.%20If%20you%20choose%20to%20do%20so%2C%20you%20must%20apply%20to%20the%20same%20College%20for%20both%20courses.%20This%20means%20you%20could%20only%20apply%20to%20%3Ca%20href%3D%22https%3A//www.undergraduate.study.cam.ac.uk/colleges/lucy-cavendish-college
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/interview-preparation
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/reconsideration-eligibility
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/sixth-term-exam-STEP
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/written-work-portfolio
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/application-dates-deadlines
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/accepted-qualifications
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/choosing-high-school-subjects
application_pages_20250316_012631.json,University of Cambridge,https://www.ucas.com/undergraduate/applying-university/individual-needs/ucas-undergraduate-care-experienced-students
application_pages_20250316_012631.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/applying/decisions/information-new-undergraduates
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/entry-requirements
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/improve-application
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/mature-student-applications
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/how/cambridge-application
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/how/admission-tests
application_pages_20250316_012631.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/new-undergraduate-students
application_pages_20250316_012631.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/ai-and-undergraduate-applications
application_pages_20250316_012631.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/before/second-undergraduate-degree
application_pages_20250316_012631.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/admissions-policy
application_pages_20250316_012631.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses?ucam-ref=home-firstug
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/colleges/choosing-a-college?ucam-ref=home-firstug
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/find-out-more/getting-here?ucam-ref=home-firstug
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/international-students?ucam-ref=home-firstug
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses?ucam-ref=homepage-signpost
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk?ucam-ref=homepage-signpost
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=home-menu
application_pages_20250316_014123.json,University of Cambridge,https://www.postgraduate.study.cam.ac.uk/application-process/how-do-i-apply?ucam-ref=home-action
application_pages_20250316_014123.json,University of Cambridge,https://www.postgraduate.study.cam.ac.uk/application-process/how-do-i-apply?ucam-ref=home-firstpg
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/applying?ucam-ref=home-firstug
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=global-footer
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/new-undergraduate-students
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/ai-and-undergraduate-applications
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/admissions-policy
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/applying?ucam-ref=home-action
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/second-undergraduate-degree
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/application-outcomes
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/apply-for-reconsideration
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/cambridge-interviews
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/application-decisions
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses/medicine-mb-bchir%22%3EStandard%20Course%20%28A100%29%3C/a%3E%C2%A0and%20the%20%3Ca%20href%3D%22https%3A//www.undergraduate.study.cam.ac.uk/courses/medicine-graduate-course-mb-bchir%22%3EGraduate%20Course%20%28A101%29%3C/a%3E.%20If%20you%20choose%20to%20do%20so%2C%20you%20must%20apply%20to%20the%20same%20College%20for%20both%20courses.%20This%20means%20you%20could%20only%20apply%20to%20%3Ca%20href%3D%22https%3A//www.undergraduate.study.cam.ac.uk/colleges/lucy-cavendish-college
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/complaints
application_pages_20250316_014123.json,University of Cambridge,https://www.ucas.com/undergraduate/after-you-apply/types-offer/replying-your-ucas-undergraduate-offers
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/contextual-data
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/criminal-convictions
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/interview-preparation
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/exam-results
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/reconsideration-eligibility
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/sixth-term-exam-STEP
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/college-assessments
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/written-work-portfolio
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/accepted-qualifications
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/choosing-high-school-subjects
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/entry-requirements
application_pages_20250316_014123.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/applying/decisions/information-new-undergraduates
application_pages_20250316_014123.json,University of Cambridge,https://www.ucas.com/undergraduate/applying-university/individual-needs/ucas-undergraduate-care-experienced-students
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/application-dates-deadlines
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/mature-student-applications
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/improve-application
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/how/cambridge-application
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/how/admission-tests
application_pages_20250316_014123.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/new-undergraduate-students
application_pages_20250316_014123.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/ai-and-undergraduate-applications
application_pages_20250316_014123.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/before/second-undergraduate-degree
application_pages_20250316_014123.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply
application_pages_20250316_014123.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/admissions-policy
application_pages_20250316_014123.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/application-decisions
application_pages_20250316_014123.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/application-outcomes
application_pages_20250316_014123.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/apply-for-reconsideration
application_pages_20250316_014123.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/cambridge-interviews
application_pages_20250316_014123.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/complaints
application_pages_20250316_014123.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/college-assessments
application_pages_20250316_014123.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/criminal-convictions
application_pages_20250316_014123.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/exam-results
application_pages_20250316_014123.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/contextual-data
application_pages_20250316_014123.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/interview-preparation
application_pages_20250316_014123.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/reconsideration-eligibility
application_pages_20250316_014123.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/sixth-term-exam-STEP
application_pages_20250316_014123.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/written-work-portfolio
application_pages_20250316_014123.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/application-dates-deadlines
application_pages_20250316_014123.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/
application_pages_20250316_105307.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/
application_pages_20250316_105307.json,"University of California, Berkeley (UCB)",https://bconnected.berkeley.edu/
application_pages_20250316_105307.json,"University of California, Berkeley (UCB)",https://financialaid.berkeley.edu/apply-now/apply-for-aid
application_pages_20250316_105307.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply
application_pages_20250316_105307.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/first-year
application_pages_20250316_105307.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/first-year/
application_pages_20250316_105307.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/freshman
application_pages_20250316_105307.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/freshman/
application_pages_20250316_105307.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/transfer
application_pages_20250316_105307.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/transfer/
application_pages_20250316_105307.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/
application_pages_20250316_105307.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/application
application_pages_20250316_105307.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/admission/apply
application_pages_20250316_105307.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/admission/first-year
application_pages_20250316_105307.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/admission/freshman
application_pages_20250316_113738.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=home-menu
application_pages_20250316_113738.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=global-footer
application_pages_20250316_113738.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply?ucam-ref=home-firstug
application_pages_20250316_113738.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply?ucam-ref=home-action
application_pages_20250316_113738.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/
application_pages_20250316_113738.json,Stanford University,https://gradadmissions.stanford.edu/
application_pages_20250316_113738.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=homepage-signpost
application_pages_20250316_113738.json,Stanford University,https://gradadmissions.stanford.edu/explore-programs
application_pages_20250316_113738.json,Stanford University,https://undergrad.stanford.edu/
application_pages_20250316_113738.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/colleges/choosing-a-college?ucam-ref=home-firstug
application_pages_20250316_113738.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/ai-and-undergraduate-applications
application_pages_20250316_113738.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/second-undergraduate-degree
application_pages_20250316_113738.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/new-undergraduate-students
application_pages_20250316_113738.json,UCL,https://www.ucl.ac.uk/
application_pages_20250316_113738.json,Stanford University,https://gradadmissions.stanford.edu/apply/
application_pages_20250316_113738.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply
application_pages_20250316_113738.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/first-year
application_pages_20250316_113738.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/first-year/
application_pages_20250316_113738.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/freshman
application_pages_20250316_113738.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/freshman/
application_pages_20250316_113738.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/transfer
application_pages_20250316_113738.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/transfer/
application_pages_20250316_113738.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/apply/
application_pages_20250316_113738.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/application
application_pages_20250316_113738.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/admission/apply
application_pages_20250316_113738.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/admission/first-year
application_pages_20250316_113738.json,"University of California, Berkeley (UCB)",https://admissions.berkeley.edu/admission/freshman
application_pages_20250316_113738.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses?ucam-ref=home-firstug
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=global-footer
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/international-students?ucam-ref=home-firstug
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk?ucam-ref=homepage-signpost
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses?ucam-ref=homepage-signpost
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/find-out-more/getting-here?ucam-ref=home-firstug
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/?ucam-ref=home-menu
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/colleges/choosing-a-college?ucam-ref=home-firstug
application_pages_20250315_170448.json,University of Cambridge,https://www.postgraduate.study.cam.ac.uk/application-process/how-do-i-apply?ucam-ref=home-action
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/applying?ucam-ref=home-action
application_pages_20250315_170448.json,University of Cambridge,https://www.postgraduate.study.cam.ac.uk/application-process/how-do-i-apply?ucam-ref=home-firstpg
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/applying?ucam-ref=home-firstug
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/new-undergraduate-students
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/second-undergraduate-degree
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/admissions-policy
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/application-decisions
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/ai-and-undergraduate-applications
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/application-outcomes
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/apply-for-reconsideration
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/courses/medicine-mb-bchir%22%3EStandard%20Course%20%28A100%29%3C/a%3E%C2%A0and%20the%20%3Ca%20href%3D%22https%3A//www.undergraduate.study.cam.ac.uk/courses/medicine-graduate-course-mb-bchir%22%3EGraduate%20Course%20%28A101%29%3C/a%3E.%20If%20you%20choose%20to%20do%20so%2C%20you%20must%20apply%20to%20the%20same%20College%20for%20both%20courses.%20This%20means%20you%20could%20only%20apply%20to%20%3Ca%20href%3D%22https%3A//www.undergraduate.study.cam.ac.uk/colleges/lucy-cavendish-college
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/college-assessments
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/cambridge-interviews
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/criminal-convictions
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/exam-results
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/interview-preparation
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/complaints
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/contextual-data
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/reconsideration-eligibility
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/sixth-term-exam-STEP
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/after/written-work-portfolio
application_pages_20250315_170448.json,University of Cambridge,https://www.ucas.com/undergraduate/after-you-apply/types-offer/replying-your-ucas-undergraduate-offers
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/application-dates-deadlines
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/accepted-qualifications
application_pages_20250315_170448.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/applying/decisions/information-new-undergraduates
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/choosing-high-school-subjects
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/before/entry-requirements
application_pages_20250315_170448.json,University of Cambridge,https://www.ucas.com/undergraduate/applying-university/individual-needs/ucas-undergraduate-care-experienced-students
application_pages_20250315_170448.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/new-undergraduate-students
application_pages_20250315_170448.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/ai-and-undergraduate-applications
application_pages_20250315_170448.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/before/second-undergraduate-degree
application_pages_20250315_170448.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply
application_pages_20250315_170448.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/admissions-policy
application_pages_20250315_170448.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/application-decisions
application_pages_20250315_170448.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/application-outcomes
application_pages_20250315_170448.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/apply-for-reconsideration
application_pages_20250315_170448.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/cambridge-interviews
application_pages_20250315_170448.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/college-assessments
application_pages_20250315_170448.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/complaints
application_pages_20250315_170448.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/contextual-data
application_pages_20250315_170448.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/criminal-convictions
application_pages_20250315_170448.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/exam-results
application_pages_20250315_170448.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/interview-preparation
application_pages_20250315_170448.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/sixth-term-exam-STEP
application_pages_20250315_170448.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/reconsideration-eligibility
application_pages_20250315_170448.json,University of Cambridge,http://www.undergraduate.study.cam.ac.uk/apply/after/written-work-portfolio
application_pages_20250315_170448.json,University of Cambridge,https://www.undergraduate.study.cam.ac.uk/apply/



================================================
File: analysis/__init__.py
================================================



================================================
File: analysis/ai_evaluator.py
================================================
"""
AI evaluation of application pages using OpenAI
"""

import asyncio
import re
import time
from datetime import datetime

import openai
from loguru import logger

from analysis.external_system_url_generator import extract_application_system_from_html

from config import Config


# API rate limiting
api_semaphore = asyncio.Semaphore(Config.MAX_CONCURRENT_API_CALLS)

# Global tracker for API metrics with lock
api_metrics = {
    "prompt_tokens": 0,
    "completion_tokens": 0,
    "total_tokens": 0,
    "estimated_cost_usd": 0.0,
    "pages_evaluated": 0,
}
api_metrics_lock = asyncio.Lock()


def parse_evaluation_response(result_text):
    """Parse the enhanced AI evaluation response including external system information."""
    result_match = re.search(r"RESULT:\s*(TRUE|FALSE)", result_text, re.IGNORECASE)
    category_match = re.search(r"CATEGORY:\s*([1-4])", result_text, re.IGNORECASE)
    explanation_match = re.search(
        r"EXPLANATION:\s*(.*?)(\n\w+:|$)", result_text, re.DOTALL
    )

    # Extract external systems information
    external_systems_match = re.search(
        r"EXTERNAL_SYSTEMS:\s*(.*?)(\n\w+:|$)", result_text, re.DOTALL
    )
    institution_code_match = re.search(
        r"INSTITUTION_CODE:\s*(.*?)(\n\w+:|$)", result_text, re.DOTALL
    )
    program_code_match = re.search(
        r"PROGRAM_CODE:\s*(.*?)(\n\w+:|$)", result_text, re.DOTALL
    )

    is_actual_application = False
    category = 0
    explanation = "Could not evaluate"

    # External systems information
    external_systems = []
    institution_code = None
    program_code = None

    if result_match:
        is_actual_application = result_match.group(1).upper() == "TRUE"

    if category_match:
        category = int(category_match.group(1))

    if explanation_match:
        explanation = explanation_match.group(1).strip()

    # Extract external systems
    if external_systems_match:
        systems_text = external_systems_match.group(1).strip()
        if systems_text.lower() != "none":
            # Split by commas or other separators
            system_candidates = re.split(r"[,;]|\sand\s", systems_text)
            for system in system_candidates:
                system = system.strip().lower()
                if system and system != "none":
                    # Map to standardized system names
                    if "ucas" in system:
                        external_systems.append("ucas")
                    elif "common app" in system or "commonapp" in system:
                        external_systems.append("common_app")
                    elif "coalition" in system:
                        external_systems.append("coalition")
                    elif "applytexas" in system or "apply texas" in system:
                        external_systems.append("applytexas")
                    elif "calstate" in system or "cal state" in system:
                        external_systems.append("cal_state")
                    elif "ouac" in system:
                        external_systems.append("ouac")
                    elif "uac" in system:
                        external_systems.append("uac")
                    elif "studylink" in system:
                        external_systems.append("studylink")
                    elif "uni-assist" in system or "uniassist" in system:
                        external_systems.append("uni_assist")
                    elif "gradcas" in system or "graduate" in system:
                        external_systems.append("postgrad")

    # Extract codes
    if institution_code_match:
        code_text = institution_code_match.group(1).strip()
        if code_text.lower() != "none":
            institution_code = code_text

    if program_code_match:
        code_text = program_code_match.group(1).strip()
        if code_text.lower() != "none":
            program_code = code_text

    # Create additional metadata about the type of application page
    application_type = "N/A"
    if category == 1:
        application_type = "direct_application"
    elif category == 2:
        application_type = "external_application_reference"
    elif category == 3:
        application_type = "information_only"

    return (
        is_actual_application,
        explanation,
        application_type,
        category,
        external_systems,
        institution_code,
        program_code,
    )


async def evaluate_application_page(app_page):
    """Use GPT-4o-mini to evaluate if a page is truly an application page."""
    global api_metrics, api_metrics_lock

    try:
        # Use semaphore to limit concurrent API calls
        async with api_semaphore:
            system_prompt = """
            You are an expert at analyzing university websites and identifying actual application pages versus informational pages.
            
            Please classify this page into ONE of the following categories:
            1. DIRECT APPLICATION PAGE: Contains actual application form, immediate "Apply Now" buttons, login portal for applicants, or direct links to begin an application
            2. APPLICATION PORTAL REFERENCE: References external application systems (like UCAS, Common App, etc.) with specific instructions on how to use them for this university
            3. INFORMATION ONLY: Contains general information but no specific application instructions or requirements

            Look carefully for:
            - References to external application systems or portals (UCAS, Common App, Coalition App, UC Application, ApplyTexas, Cal State Apply, etc.)
            - Multi-step application instructions or workflows
            - Application deadlines and requirements
            - Specific codes or identifiers needed for applications (institution codes, program codes)
            - Links or references to university-specific application portals or systems
            - Instructions on what happens after submitting an initial application
            - Whether this is for undergraduate or graduate/doctoral programs

            Your task:
            - Respond with TRUE if this is category 1 or 2 (directly useful for applying)
            - Respond with FALSE if this is category 3 (just information)
            - Then provide a brief explanation for your decision and identify which category (1-3) it belongs to
            - If you find any specific external application systems (UCAS, Common App, etc.), institution codes, or program codes, mention them explicitly.
            - Determine if this is for undergraduate, graduate, or doctoral programs.

            Format your response like this:
            RESULT: TRUE/FALSE
            CATEGORY: 1/2/3
            EXPLANATION: Your explanation here
            EXTERNAL_SYSTEMS: List any external systems mentioned (UCAS, Common App, UC Application, etc.) or NONE
            INSTITUTION_CODE: Any institution codes found or NONE
            PROGRAM_CODE: Any program codes found or NONE
            EDUCATION_LEVEL: undergraduate/graduate/doctoral/unknown
            """

            user_prompt = f"""
            Analyze this university webpage and determine if it is an application-related page where students can either apply directly or get critical information needed to apply to the university.
            
            You are given the following information:

            University: {app_page['university']}
            Page Title: {app_page['title']}
            URL: {app_page['url']}
            Detected Reasons: {', '.join(app_page['reasons'])}
            
            Please be extremely precise in identifying if this is for undergraduate applications or graduate/doctoral programs. Specifically look for terms like "undergraduate", "freshmen", "first-year", "transfer" for undergraduate, versus "graduate", "master's", "PhD", "doctoral" for graduate programs.
            
            Also carefully identify any external application systems (like UCAS for UK universities, Common App for US colleges, UC Application for University of California campuses, etc.) that are mentioned or referenced.
            """

            # Use the synchronous API but run it in a separate thread to keep things async
            loop = asyncio.get_event_loop()
            response = await loop.run_in_executor(
                None,
                lambda: openai.chat.completions.create(
                    model=Config.MODEL_NAME,
                    messages=[
                        {
                            "role": "system",
                            "content": system_prompt,
                        },
                        {"role": "user", "content": user_prompt},
                    ],
                    temperature=0.1,
                ),
            )

            # Track metrics with async lock to prevent race conditions
            async with api_metrics_lock:
                api_metrics["prompt_tokens"] += response.usage.prompt_tokens
                api_metrics["completion_tokens"] += response.usage.completion_tokens
                api_metrics["total_tokens"] += response.usage.total_tokens
                api_metrics["pages_evaluated"] += 1

                # Calculate cost based on model pricing - adjust rates as needed
                rate_per_1k_input = 0.00015  # Rate for GPT-4o-mini prompt tokens
                rate_per_1k_completion = (
                    0.0006  # Rate for GPT-4o-mini completion tokens
                )
                rate_per_1k_cached_input = (
                    0.000075  # Rate for GPT-4o-mini cached prompt tokens
                )

                page_cost = (
                    (response.usage.prompt_tokens / 1000) * rate_per_1k_input
                    + (response.usage.prompt_tokens_details.cached_tokens / 1000)
                    * rate_per_1k_cached_input
                    + (response.usage.completion_tokens / 1000) * rate_per_1k_completion
                )
                api_metrics["estimated_cost_usd"] += page_cost

            result_text = response.choices[0].message.content.strip()

            # Parse the response with our new function - fixed to capture all return values
            (
                is_actual_application,
                explanation,
                application_type,
                category,
                external_systems,
                institution_code,
                program_code,
            ) = parse_evaluation_response(result_text)

            # Extract external systems from HTML directly
            html_content = app_page.get("html_snippet", "")
            university_name = app_page.get("university", "")

            # Use our new function to get application system URLs
            application_systems = extract_application_system_from_html(
                html_content, app_page["url"], university_name
            )

            # Create evaluated entry
            evaluated_entry = app_page.copy()
            evaluated_entry.pop(
                "html_snippet", None
            )  # Remove HTML snippet to save space
            evaluated_entry["is_actual_application"] = is_actual_application
            evaluated_entry["ai_evaluation"] = explanation
            evaluated_entry["application_type"] = application_type
            evaluated_entry["category"] = category

            # Add the external application systems information
            if application_systems:
                evaluated_entry["external_application_systems"] = application_systems
            else:
                evaluated_entry["external_application_systems"] = []

            # Add additional fields from AI evaluation
            if external_systems:
                evaluated_entry["detected_external_systems"] = external_systems
            if institution_code:
                evaluated_entry["institution_code"] = institution_code
            if program_code:
                evaluated_entry["program_code"] = program_code

            log_prefix = (
                "✅ ACTUAL APPLICATION"
                if is_actual_application
                else "❌ NOT APPLICATION"
            )

            # Log if external systems were found
            if application_systems:
                systems_found = ", ".join(
                    [sys["system_name"] for sys in application_systems]
                )
                logger.info(
                    f"Evaluated {app_page['url']}: {log_prefix} | External Systems: {systems_found}"
                )
            else:
                logger.info(f"Evaluated {app_page['url']}: {log_prefix}")

            return evaluated_entry

    except Exception as e:
        logger.error(f"Error evaluating {app_page['url']}: {e}")

        # Return with error message
        evaluated_entry = app_page.copy()
        evaluated_entry.pop("html_snippet", None)
        evaluated_entry["is_actual_application"] = False
        evaluated_entry["ai_evaluation"] = f"Error during evaluation: {str(e)}"
        evaluated_entry["application_type"] = "error"
        evaluated_entry["category"] = 0
        evaluated_entry["external_application_systems"] = []

        return evaluated_entry


async def evaluate_all_applications(found_applications):
    """Evaluate all found application pages using GPT-4o-mini."""

    if not found_applications:
        logger.warning("No application pages to evaluate")
        return []

    logger.info(
        f"Evaluating {len(found_applications)} application pages with {Config.MODEL_NAME}..."
    )

    # Evaluate in batches to avoid overwhelming the API
    results = []
    batch_size = Config.MAX_EVAL_BATCH

    for i in range(0, len(found_applications), batch_size):
        batch = found_applications[i : i + batch_size]
        logger.info(
            f"Evaluating batch {i//batch_size + 1} of {(len(found_applications)-1)//batch_size + 1} ({len(batch)} pages)"
        )

        # Process the batch concurrently
        batch_results = await asyncio.gather(
            *[evaluate_application_page(app) for app in batch]
        )
        results.extend(batch_results)

        # Brief pause between batches
        if i + batch_size < len(found_applications):
            await asyncio.sleep(1)

    return results


def get_api_metrics():
    """Return a copy of the current API metrics."""
    global api_metrics

    metrics = api_metrics.copy()
    metrics["timestamp"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    metrics["model"] = Config.MODEL_NAME

    return metrics



================================================
File: analysis/application_url_utils.py
================================================
"""
Utility module for easily retrieving application system URLs
"""

from static_application_urls import get_application_system_url


def get_urls_for_university(university_name, systems=None):
    """
    Get application URLs for a specific university across multiple systems

    Args:
        university_name (str): The name of the university
        systems (list, optional): List of systems to check, or None for all common systems

    Returns:
        dict: Dictionary of application URLs keyed by system name
    """
    # Default to common systems if none provided
    if not systems:
        systems = [
            "ucas",
            "common_app",
            "coalition",
            "applytexas",
            "cal_state",
            "uc_app",
            "ouac",
            "uac",
            "uni_assist",
        ]

    results = {}

    for system in systems:
        system_info = get_application_system_url(system, university_name)

        # Only include systems with a base URL
        if "base_url" in system_info:
            results[system] = {
                "name": system_info["name"],
                "base_url": system_info["base_url"],
            }

            # Add search URL if available
            if "institution_search_url" in system_info:
                results[system]["search_url"] = system_info["institution_search_url"]

    return results


def get_system_url_by_region(university_name, region):
    """
    Get the most appropriate application system URL based on geographic region

    Args:
        university_name (str): The name of the university
        region (str): Geographic region (e.g., "UK", "US", "Australia", "Canada", "Germany")

    Returns:
        dict: Information about the most relevant application system
    """
    # Map regions to application systems
    region_map = {
        "uk": "ucas",
        "united kingdom": "ucas",
        "england": "ucas",
        "scotland": "ucas",
        "wales": "ucas",
        "northern ireland": "ucas",
        "us": "common_app",
        "usa": "common_app",
        "united states": "common_app",
        "australia": "uac",
        "nsw": "uac",
        "act": "uac",
        "canada": "ouac",
        "ontario": "ouac",
        "germany": "uni_assist",
        "deutschland": "uni_assist",
        "texas": "applytexas",
        "tx": "applytexas",
        "california": "cal_state",
        "ca": "cal_state",
        "new zealand": "studylink",
        "nz": "studylink",
    }

    # Normalize region
    normalized_region = region.lower().strip()

    # Get the appropriate system
    system = region_map.get(
        normalized_region, "common_app"
    )  # Default to Common App if region unknown

    # Get and return the system URL
    return get_application_system_url(system, university_name)


def lookup_institution_code(university_name, system="ucas"):
    """
    Lookup institution codes for universities in specific application systems

    This is a simple mock implementation with a few example codes.
    In a real implementation, this would connect to a database of institution codes.

    Args:
        university_name (str): The name of the university
        system (str): The application system to check

    Returns:
        str: Institution code if found, otherwise None
    """
    # Normalize university name
    univ_name = university_name.lower().strip()

    # Mock database of institution codes
    ucas_codes = {
        "university of cambridge": "CAM",
        "university of oxford": "OXFD",
        "imperial college london": "IMP",
        "university college london": "UCL",
        "london school of economics": "LSE",
        "university of edinburgh": "EDINB",
        "king's college london": "KCL",
        "university of manchester": "MANU",
    }

    common_app_codes = {
        "harvard university": "4154",
        "stanford university": "4704",
        "massachusetts institute of technology": "3514",
        "yale university": "3987",
        "princeton university": "2672",
        "columbia university": "2116",
        "university of pennsylvania": "3731",
        "california institute of technology": "4034",
    }

    # Select appropriate code database
    if system.lower() == "ucas":
        return ucas_codes.get(univ_name)
    elif system.lower() in ["common_app", "common", "commonapp"]:
        return common_app_codes.get(univ_name)
    else:
        return None


def print_application_guidance(university_name, system=None):
    """
    Print user-friendly guidance for applying to a university

    Args:
        university_name (str): The name of the university
        system (str, optional): Specific application system to use

    Returns:
        str: Formatted guidance text
    """
    if system:
        # Get specific system info
        system_info = get_application_system_url(system, university_name)

        # Build guidance text
        guidance = f"APPLICATION GUIDANCE FOR {university_name.upper()} VIA {system_info['name'].upper()}\n\n"
        guidance += f"Application Website: {system_info.get('base_url', 'Check university website')}\n\n"

        if "institution_search_url" in system_info:
            guidance += (
                f"University Search URL: {system_info['institution_search_url']}\n\n"
            )

        guidance += f"Description: {system_info['description']}\n\n"

        if "application_steps" in system_info:
            guidance += "Application Steps:\n"
            for i, step in enumerate(system_info["application_steps"], 1):
                guidance += f"{i}. {step}\n"

        # Add institution code if available
        inst_code = lookup_institution_code(university_name, system)
        if inst_code:
            guidance += f"\nInstitution Code: {inst_code}\n"

        return guidance
    else:
        # Get URLs for multiple systems
        urls = get_urls_for_university(university_name)

        # Build guidance text
        guidance = f"APPLICATION OPTIONS FOR {university_name.upper()}\n\n"
        guidance += f"The following application systems may be available for {university_name}:\n\n"

        for system, info in urls.items():
            guidance += f"- {info['name']}: {info['base_url']}\n"
            if "search_url" in info:
                guidance += f"  Search URL: {info['search_url']}\n"

        guidance += "\nPlease check the university's official website to confirm which application system to use."

        return guidance



================================================
File: analysis/external_system_url_generator.py
================================================
"""
Functions to generate URLs for external application systems
"""

import re

from analysis.page_analyzer import EXTERNAL_APPLICATION_SYSTEMS


# Base URLs for common external application systems
APPLICATION_SYSTEM_URLS = {
    "ucas": "https://www.ucas.com/apply",
    "common_app": "https://apply.commonapp.org/login",
    "coalition": "https://app.commonapp.org/apply/coalition",
    "applytexas": "https://www.applytexas.org/adappc/gen/c_start.WBX",
    "cal_state": "https://www.calstate.edu/apply",
    "ouac": "https://www.ouac.on.ca/apply/",
    "uac": "https://www5.uac.edu.au/uacug/",
    "studylink": "https://www.studylink.govt.nz/apply/",
    "uni_assist": "https://www.uni-assist.de/en/how-to-apply/",
    "postgrad": "https://graduateadmissions.herokuapp.com/",  # Generic placeholder for graduate systems
}


# Advanced URL construction for systems that need institution-specific parameters
def get_system_url(
    system_name, university=None, program_code=None, institution_code=None
):
    """
    Generate a URL for an external application system, with optional parameters for
    university-specific links.

    Args:
        system_name (str): The name of the external application system
        university (str, optional): University name for system-specific URLs
        program_code (str, optional): Program code for certain application systems
        institution_code (str, optional): Institution code for certain application systems

    Returns:
        dict: A dictionary containing the system name, base URL, and any additional information
    """

    # Initialize result dictionary
    result = {
        "system_name": system_name,
        "base_url": APPLICATION_SYSTEM_URLS.get(system_name.lower(), ""),
        "university_specific_url": None,
        "additional_info": None,
    }

    # Handle system-specific URL construction
    if system_name.lower() == "ucas" and institution_code:
        result["additional_info"] = f"UCAS Institution Code: {institution_code}"
        if program_code:
            result["additional_info"] += f", Program Code: {program_code}"

    elif system_name.lower() == "common_app" and university:
        # Format university name for potential search parameter
        univ_param = university.lower().replace(" ", "-")
        result["university_specific_url"] = f"{result['base_url']}?search={univ_param}"

    elif system_name.lower() == "applytexas" and institution_code:
        result["additional_info"] = f"ApplyTexas Institution Code: {institution_code}"

    elif system_name.lower() == "ouac" and university:
        # OUAC has different application paths (101 for undergrad, 105 for transfer, etc.)
        result["base_url"] = "https://www.ouac.on.ca/apply/"
        result["additional_info"] = (
            "You may need to select the appropriate OUAC form (101, 105, etc.)"
        )

    # Return the constructed result
    return result


def extract_application_system_from_html(html, url, university_name):
    """
    Extract external application system references from HTML content
    and generate appropriate application URLs.

    Args:
        html (str): The HTML content of the page
        url (str): The URL of the page
        university_name (str): The name of the university

    Returns:
        list: List of dictionaries containing application system information
    """

    results = []
    html_lower = html.lower()

    # Extract potential institution codes
    institution_code = None
    program_code = None

    # Look for institution codes (common formats)
    inst_code_patterns = [
        r"institution code:?\s*([A-Z0-9]{4,6})",
        r"college code:?\s*([A-Z0-9]{4,6})",
        r"university code:?\s*([A-Z0-9]{4,6})",
        r"ucas code:?\s*([A-Z0-9]{4,6})",
    ]

    for pattern in inst_code_patterns:
        code_match = re.search(pattern, html_lower)
        if code_match:
            institution_code = code_match.group(1).upper()
            break

    # Look for program codes
    prog_code_patterns = [
        r"program code:?\s*([A-Z0-9]{3,8})",
        r"course code:?\s*([A-Z0-9]{3,8})",
    ]

    for pattern in prog_code_patterns:
        code_match = re.search(pattern, html_lower)
        if code_match:
            program_code = code_match.group(1).upper()
            break

    # Check for each application system
    for system, identifiers in EXTERNAL_APPLICATION_SYSTEMS.items():
        for identifier in identifiers:
            if identifier in html_lower:
                # Create a system URL result
                system_url_info = get_system_url(
                    system,
                    university=university_name,
                    program_code=program_code,
                    institution_code=institution_code,
                )

                # Add the reference that was found
                system_url_info["found_reference"] = identifier

                # Add to results if not already present
                if not any(r["system_name"] == system for r in results):
                    results.append(system_url_info)

    return results



================================================
File: analysis/link_extractor.py
================================================
"""
Improved link extraction with proper HTML parsing
Replaces regex-based extraction with HTML parser
"""

import asyncio
from urllib.parse import urljoin, urlparse, unquote
from html.parser import HTMLParser
from loguru import logger

from utils.url_utils import is_valid_url, normalize_url


class LinkExtractorParser(HTMLParser):
    """HTML Parser specifically for extracting links."""

    def __init__(self, base_url):
        super().__init__()
        self.base_url = base_url
        self.links = []

    def handle_starttag(self, tag, attrs):
        if tag == "a":
            # Extract href attribute
            for attr, value in attrs:
                if attr == "href" and value:
                    # Skip empty links, javascript, mailto, tel links, and fragments
                    if not value or value.startswith(
                        ("javascript:", "mailto:", "tel:", "#")
                    ):
                        continue

                    # Clean the URL - handle URL encoding issues
                    try:
                        # Decode any URL encoded characters
                        value = unquote(value)

                        # Remove any HTML that might be part of the URL
                        if "<" in value or ">" in value:
                            value = value.split("<")[0].split(">")[0]

                        # Resolve relative URLs
                        full_url = urljoin(self.base_url, value)

                        # Normalize URL
                        normalized = normalize_url(full_url)

                        # Validate URL and add to list
                        if normalized and is_valid_url(normalized):
                            # Check for suspicious URL patterns
                            if self._is_suspicious_url(normalized):
                                logger.warning(f"Skipping suspicious URL: {normalized}")
                                continue

                            self.links.append(normalized)
                    except Exception as e:
                        logger.debug(f"Error processing URL {value}: {e}")

    def _is_suspicious_url(self, url):
        """Check for suspicious URL patterns that might indicate a loop."""
        try:
            parsed = urlparse(url)
            path = parsed.path

            # Check for repeating patterns in the path
            path_parts = [p for p in path.split("/") if p]

            # Look for the same path component repeated multiple times in sequence
            for i in range(len(path_parts) - 1):
                if path_parts[i] == path_parts[i + 1]:
                    return True

            # Check for unusually long paths (may indicate a loop)
            if len(path_parts) > 15:  # Arbitrary threshold for demonstration
                return True

            # Check for malformed URLs containing HTML tags or unusual characters
            suspicious_chars = ["<", ">", '"', "'", "%22", "%3C", "%3E"]
            if any(char in url for char in suspicious_chars):
                return True

            return False
        except Exception:
            # If we can't parse it, consider it suspicious
            return True


def extract_links(url, html):
    """Extract links from HTML content using proper HTML parsing."""
    if not html:
        return []

    # Initialize parser
    parser = LinkExtractorParser(url)

    try:
        # Feed HTML to parser
        parser.feed(html)
        return parser.links
    except Exception as e:
        logger.error(f"Error extracting links from {url}: {e}")
        return []



================================================
File: analysis/page_analyzer.py
================================================
"""
Page analysis utilities for identifying application pages
"""

import re
from urllib.parse import urlparse

from loguru import logger
from config import Config

# Dictionary of known application systems with their identifiers
EXTERNAL_APPLICATION_SYSTEMS = {
    "ucas": [
        "ucas.com",
        "ucas application",
        "ucas form",
        "ucas portal",
        "ucas code",
        "apply through ucas",
    ],
    "common_app": [
        "commonapp.org",
        "common app",
        "common application",
        "commonapp",
        "apply via common app",
    ],
    "coalition": [
        "coalitionapp",
        "coalition application",
        "coalition for college",
        "mycoalition",
    ],
    "applytexas": ["applytexas", "apply texas"],
    "cal_state": ["calstate.edu/apply", "cal state apply", "csu apply"],
    "ouac": ["ouac.on.ca", "ontario universities", "ouac form", "ouac application"],
    "uac": ["uac.edu.au", "universities admissions centre", "uac application"],
    "studylink": ["studylink.govt.nz", "study link application"],
    "uni_assist": ["uni-assist.de", "uniassist", "uni assist application"],
    "postgrad": ["postgraduateapply", "gradcas", "graduate application system"],
}


def extract_title(html):
    """Extract page title from HTML with Unicode support."""

    if not html:
        return ""

    title_match = re.search(
        r"<title[^>]*>(.*?)</title>", html, re.IGNORECASE | re.DOTALL
    )
    if title_match:
        title = title_match.group(1).strip()
        # Clean up common HTML entities
        title = re.sub(r"&amp;", "&", title)
        title = re.sub(r"&lt;", "<", title)
        title = re.sub(r"&gt;", ">", title)
        title = re.sub(r"&quot;", '"', title)
        title = re.sub(r"&#(\d+);", lambda m: chr(int(m.group(1))), title)
        return title
    return ""


def is_application_page(url, html, title=""):
    """Check if a page is likely an application page."""
    if not html:
        return False, []

    reasons = []
    score = 0  # Track a confidence score

    # Parse URL components
    parsed = urlparse(url)
    domain = parsed.netloc.lower()
    path = parsed.path.lower()

    # Domain-level checks (subdomain indicates strong likelihood)
    if any(x in domain for x in ["admission", "apply", "applicant", "undergrad"]):
        reasons.append(f"URL subdomain suggests application page: {domain}")
        score += 3

    # Path-level checks - give higher weight to specific patterns
    for pattern in Config.HIGH_PRIORITY_PATTERNS:
        if pattern in path:
            reasons.append(f"URL contains high-priority pattern '{pattern}'")
            score += 2

    # Check for application keywords in URL
    for keyword in Config.APPLICATION_KEYWORDS:
        if keyword in path:
            reasons.append(f"URL contains keyword '{keyword}'")
            score += 1

    # Check title for application keywords - strong indicator
    if title:
        title_lower = title.lower()
        for keyword in Config.APPLICATION_KEYWORDS:
            if keyword in title_lower:
                reasons.append(f"Title contains keyword '{keyword}'")
                score += 2

        # Check for direct application indicators in title
        for indicator in Config.APPLICATION_FORM_INDICATORS:
            if indicator in title_lower:
                reasons.append(
                    f"Title contains application form indicator '{indicator}'"
                )
                score += 3

    # Check meta description for application keywords
    meta_desc_match = re.search(
        r'<meta[^>]*name=["\']description["\'][^>]*content=["\'](.*?)["\']',
        html,
        re.IGNORECASE,
    )
    if meta_desc_match:
        meta_desc = meta_desc_match.group(1).lower()
        for keyword in Config.APPLICATION_KEYWORDS:
            if keyword in meta_desc:
                reasons.append(f"Meta description contains keyword '{keyword}'")
                score += 1

        # Check for direct application indicators in meta description
        for indicator in Config.APPLICATION_FORM_INDICATORS:
            if indicator in meta_desc:
                reasons.append(
                    f"Meta description contains application form indicator '{indicator}'"
                )
                score += 2

    # Check for form with application-related attributes
    form_action_matches = re.findall(
        r'<form[^>]*action=["\'](.*?)["\']', html, re.IGNORECASE
    )
    for action in form_action_matches:
        action_lower = action.lower()
        for keyword in Config.APPLICATION_KEYWORDS:
            if keyword in action_lower:
                reasons.append(f"Form action contains keyword '{keyword}'")
                score += 3

    # Check for application-related buttons or links
    for indicator in Config.APPLICATION_FORM_INDICATORS:
        pattern = re.escape(indicator)
        if re.search(
            f"<(a|button)[^>]*>(.*?{pattern}.*?)</(a|button)>", html, re.IGNORECASE
        ):
            reasons.append(f"Contains application button/link with text '{indicator}'")
            score += 4

    # Check for Common App/Coalition App references (strong indicators)
    if re.search(
        r"common\s*app(lication)?|coalition\s*app(lication)?", html, re.IGNORECASE
    ):
        reasons.append("Page references Common App or Coalition App")
        score += 4

    # Check for login/authentication elements specifically for applicants
    if re.search(
        r"applicant\s*login|application\s*login|application\s*portal",
        html,
        re.IGNORECASE,
    ):
        reasons.append("Page contains applicant login elements")
        score += 4

    # Check for external application system references
    external_system_found = False
    external_system_name = None
    for system, identifiers in EXTERNAL_APPLICATION_SYSTEMS.items():
        for identifier in identifiers:
            if identifier in html.lower():
                external_system_found = True
                external_system_name = system
                reasons.append(f"References external application system: {identifier}")
                score += 4
                break
        if external_system_found:
            break

    # Check for university-specific application portal references
    portal_patterns = [
        r"my\s*\w+\s*application",  # "My Cambridge Application", "My Stanford Application"
        r"\w+\s*application\s*portal",  # "University Application Portal"
        r"application\s*system",
        r"applicant\s*portal",
        r"application\s*portal",
        r"application\s*account",
        r"application\s*platform",
        r"apply\s*online",
        r"online\s*application\s*(form|system)",
    ]

    for pattern in portal_patterns:
        if re.search(pattern, html.lower()):
            reasons.append(
                f"Contains reference to application portal: {re.search(pattern, html.lower()).group(0)}"
            )
            score += 3

    # Check for application process instructions
    instruction_patterns = [
        r"(how|steps)\s*to\s*apply",
        r"application\s*(process|procedure|instructions)",
        r"application\s*(deadline|due date)",
        r"(submit|complete)\s*your\s*application",
        r"after\s*(you|submitting)\s*(submit|application)",
        r"before\s*(you|submitting)\s*(submit|application)",
        r"(application|institution|college|program)\s*code",
        r"application\s*checklist",
    ]

    for pattern in instruction_patterns:
        if re.search(pattern, html.lower()):
            reasons.append(
                f"Contains application instructions: {re.search(pattern, html.lower()).group(0)}"
            )
            score += 2

    # Return based on confidence score
    return score >= 3, reasons



================================================
File: analysis/static_application_urls.py
================================================
"""
Static URL generator for external application systems
"""

from analysis.page_analyzer import EXTERNAL_APPLICATION_SYSTEMS

# Comprehensive dictionary of common application systems with their base URLs
# and additional information about how to use them
APPLICATION_SYSTEM_INFO = {
    "ucas": {
        "name": "UCAS (UK Universities and Colleges Admissions Service)",
        "base_url": "https://www.ucas.com/apply",
        "search_url": "https://digital.ucas.com/search",
        "description": "The central application service for UK undergraduate programs",
        "institution_code_format": "Four-character code (e.g., 'CAMB' for Cambridge)",
        "application_steps": [
            "Create a UCAS account",
            "Complete personal details",
            "Add course choices (up to 5)",
            "Write personal statement",
            "Get reference",
            "Pay application fee and submit",
        ],
    },
    "common_app": {
        "name": "Common Application",
        "base_url": "https://apply.commonapp.org/login",
        "search_url": "https://apply.commonapp.org/search",
        "description": "Application platform for over 900 colleges and universities, primarily in the US",
        "application_steps": [
            "Create Common App account",
            "Add colleges to your list",
            "Complete the common application form",
            "Answer college-specific questions",
            "Submit application for each college",
            "Pay application fees for each college",
        ],
    },
    "coalition": {
        "name": "Coalition Application",
        "base_url": "https://app.coalitionforcollegeaccess.org/",
        "search_url": "https://app.coalitionforcollegeaccess.org/search",
        "description": "Alternative to Common App, used by about 150 US colleges and universities",
        "application_steps": [
            "Create Coalition account",
            "Build profile",
            "Add colleges to your list",
            "Answer university-specific questions",
            "Submit your application",
        ],
    },
    "applytexas": {
        "name": "ApplyTexas",
        "base_url": "https://www.applytexas.org/adappc/gen/c_start.WBX",
        "description": "Application system for Texas public universities and community colleges",
        "application_steps": [
            "Create ApplyTexas account",
            "Select target universities",
            "Complete biographical information",
            "Complete educational background",
            "Complete residency information",
            "Submit application",
        ],
    },
    "cal_state": {
        "name": "Cal State Apply",
        "base_url": "https://www.calstate.edu/apply",
        "description": "Application portal for all California State University campuses",
        "application_steps": [
            "Create Cal State Apply account",
            "Select campuses and programs",
            "Complete four quadrants: Personal Information, Academic History, Supporting Information, and Program Materials",
            "Submit application and pay fee",
        ],
    },
    "uc_app": {
        "name": "University of California Application",
        "base_url": "https://apply.universityofcalifornia.edu/my-application/",
        "description": "Application system for all University of California campuses",
        "application_steps": [
            "Create UC application account",
            "Complete personal information",
            "Add academic history",
            "Complete personal insight questions",
            "Review and submit application",
        ],
    },
    "ouac": {
        "name": "Ontario Universities' Application Centre",
        "base_url": "https://www.ouac.on.ca/apply/",
        "description": "Central application service for universities in Ontario, Canada",
        "application_types": {
            "101": "Current Ontario high school students",
            "105": "All other applicants",
        },
        "application_steps": [
            "Select appropriate application type (101 or 105)",
            "Create OUAC account",
            "Complete personal information",
            "Select universities and programs",
            "Submit application and pay fees",
        ],
    },
    "uac": {
        "name": "Universities Admissions Centre (Australia)",
        "base_url": "https://www5.uac.edu.au/uacug/",
        "description": "Central admissions for undergraduate study at participating institutions in NSW and ACT, Australia",
        "application_steps": [
            "Create UAC account",
            "Select courses in order of preference",
            "Provide personal information",
            "Upload supporting documents",
            "Pay application fee",
        ],
    },
    "studylink": {
        "name": "StudyLink (New Zealand)",
        "base_url": "https://www.studylink.govt.nz/apply/",
        "description": "New Zealand's student loan and allowance application system",
        "application_steps": [
            "Create StudyLink account",
            "Complete application for student loan/allowance",
            "Upload supporting documents",
            "Track application status",
        ],
    },
    "uni_assist": {
        "name": "uni-assist (Germany)",
        "base_url": "https://www.uni-assist.de/en/how-to-apply/",
        "description": "Application service for international students applying to German universities",
        "application_steps": [
            "Create uni-assist account",
            "Select universities and programs",
            "Upload required documents",
            "Pay handling fee",
            "Track application status",
        ],
    },
    "postgrad_uk": {
        "name": "UK Postgraduate Application",
        "base_url": "https://www.FindAMasters.com/apply/",
        "description": "Portal for UK postgraduate degree applications",
        "application_steps": [
            "Search for programs",
            "Apply directly through university website",
            "Complete application form",
            "Provide references",
            "Submit research proposal (if applicable)",
        ],
    },
    "graduate_us": {
        "name": "US Graduate School Application",
        "description": "Most US graduate programs require direct application through their websites",
        "common_requirements": [
            "Transcripts",
            "GRE/GMAT scores (if required)",
            "Statement of purpose",
            "Letters of recommendation",
            "CV/Resume",
            "Application fee",
        ],
    },
    "cas": {
        "name": "Centralized Application Service",
        "description": "Field-specific application services in the US",
        "types": {
            "AMCAS": "Medical School (MD) - https://students-residents.aamc.org/applying-medical-school-amcas/applying-medical-school-amcas",
            "PTCAS": "Physical Therapy - https://ptcasdirectory.apta.org/",
            "CASPA": "Physician Assistant - https://caspa.liaisoncas.com/",
            "VMCAS": "Veterinary Medicine - https://www.aavmc.org/becoming-a-veterinarian/how-to-apply/",
            "LSAC": "Law School - https://www.lsac.org/",
            "SOPHAS": "Public Health - https://sophas.org/",
        },
    },
}


def get_application_system_url(system_name, institution_name=None):
    """
    Get pre-generated information about an application system including URLs

    Args:
        system_name (str): The name of the application system
        institution_name (str, optional): Institution name for more specific information

    Returns:
        dict: Information about the application system
    """
    # Normalize system name
    system_name = system_name.lower().replace(" ", "_").replace("-", "_")

    # Look for exact matches first
    if system_name in APPLICATION_SYSTEM_INFO:
        result = APPLICATION_SYSTEM_INFO[system_name].copy()

        # Add institution-specific search if provided
        if institution_name and "search_url" in result:
            search_param = institution_name.lower().replace(" ", "+")
            result["institution_search_url"] = (
                f"{result['search_url']}?q={search_param}"
            )

        return result

    # Handle aliases and partial matches
    system_aliases = {
        "ucas": ["ucas", "uk", "uk_application", "uk_undergrad"],
        "common_app": ["common", "commonapp", "common_application"],
        "coalition": ["coalition_app", "mycoalition"],
        "applytexas": ["texas", "apply_texas"],
        "cal_state": ["csu", "calstate", "california_state"],
        "uc_app": ["uc", "university_of_california", "uc_application"],
        "ouac": ["ontario", "ontario_application"],
        "uac": ["australia", "australian", "nsw"],
        "uni_assist": ["germany", "german", "uniassist"],
        "cas": ["centralized", "centralized_application", "specialized_application"],
    }

    # Check aliases
    for system, aliases in system_aliases.items():
        if system_name in aliases:
            result = APPLICATION_SYSTEM_INFO[system].copy()

            # Add institution-specific search if provided
            if institution_name and "search_url" in result:
                search_param = institution_name.lower().replace(" ", "+")
                result["institution_search_url"] = (
                    f"{result['search_url']}?q={search_param}"
                )

            return result

    # Return a general guide if no specific system is found
    return {
        "name": "General Application Guide",
        "description": "No specific information found for this application system",
        "general_steps": [
            "Check the university's official website for application instructions",
            "Note application deadlines and requirements",
            "Prepare necessary documents (transcripts, test scores, etc.)",
            "Complete and submit application form",
            "Pay application fee if required",
            "Check application status regularly",
        ],
    }


def detect_application_systems(html_content, url=""):
    """
    Detect external application systems mentioned in HTML content

    Args:
        html_content (str): HTML content to analyze
        url (str, optional): URL of the page for additional context

    Returns:
        list: List of detected application systems
    """

    detected_systems = []

    # Bail out on empty content
    if not html_content:
        return detected_systems

    # Convert to lowercase for easier matching
    html_lower = html_content.lower()

    # Check for each application system
    for system, identifiers in EXTERNAL_APPLICATION_SYSTEMS.items():
        for identifier in identifiers:
            if identifier in html_lower:
                if system not in detected_systems:
                    detected_systems.append(system)
                break

    # Add some additional checks for systems not in the original list
    additional_systems = [
        ("uc_app", ["uc application", "university of california application"]),
        ("postgrad_uk", ["uk postgraduate", "uk masters", "uk phd"]),
        ("graduate_us", ["us graduate", "us grad school"]),
        ("cas", ["amcas", "ptcas", "caspa", "vmcas", "lsac", "sophas"]),
    ]

    for system, identifiers in additional_systems:
        for identifier in identifiers:
            if identifier in html_lower:
                if system not in detected_systems:
                    detected_systems.append(system)
                break

    return detected_systems


def generate_application_urls_report(detected_systems, institution_name=None):
    """
    Generate a comprehensive report with URLs for detected application systems

    Args:
        detected_systems (list): List of detected system names
        institution_name (str, optional): Name of the institution

    Returns:
        dict: Dictionary with detailed application information
    """
    report = {
        "detected_systems": [],
        "application_urls": {},
        "general_guidance": "Always check the official university website for the most up-to-date application information.",
    }

    if not detected_systems:
        report["detected_systems"] = ["No specific application systems detected"]
        return report

    # Process each detected system
    for system in detected_systems:
        system_info = get_application_system_url(system, institution_name)

        # Add to detected systems list
        report["detected_systems"].append(system_info["name"])

        # Add detailed information to application_urls
        report["application_urls"][system] = {
            "name": system_info["name"],
            "base_url": system_info.get(
                "base_url", "Direct application through institution"
            ),
            "description": system_info["description"],
        }

        # Add application steps if available
        if "application_steps" in system_info:
            report["application_urls"][system]["application_steps"] = system_info[
                "application_steps"
            ]

        # Add institution-specific search URL if available
        if "institution_search_url" in system_info:
            report["application_urls"][system]["institution_search_url"] = system_info[
                "institution_search_url"
            ]

        # Add any other system-specific information
        if "institution_code_format" in system_info:
            report["application_urls"][system]["institution_code_format"] = system_info[
                "institution_code_format"
            ]

        if "application_types" in system_info:
            report["application_urls"][system]["application_types"] = system_info[
                "application_types"
            ]

        if "types" in system_info:
            report["application_urls"][system]["subtypes"] = system_info["types"]

        if "common_requirements" in system_info:
            report["application_urls"][system]["common_requirements"] = system_info[
                "common_requirements"
            ]

    return report




================================================
File: crawler/__init__.py
================================================



================================================
File: crawler/fetcher.py
================================================
"""
URL fetching implementation
"""

import asyncio
import random
import re
from urllib.parse import urljoin, urlparse

import aiohttp
from loguru import logger

from config import Config
from utils.encoding import EncodingHandler
from analysis.page_analyzer import is_application_page, extract_title
from analysis.link_extractor import (
    extract_links,
)
from models.state_manager import state_manager
from utils.url_utils import (
    get_url_priority,
    is_related_domain,
    normalize_url,
    is_valid_url,
)


class RedirectTracker:
    """
    Tracks redirects to detect and prevent redirect loops
    """

    def __init__(self, max_redirects=5):
        self.redirect_chains = {}  # Maps original_url -> list of redirected URLs
        self.max_redirects = max_redirects
        self.lock = asyncio.Lock()

    async def start_tracking(self, url):
        """Start tracking redirects for a URL"""
        async with self.lock:
            self.redirect_chains[url] = [url]

    async def add_redirect(self, original_url, redirected_url):
        """Add a redirect to the chain"""
        async with self.lock:
            if original_url not in self.redirect_chains:
                self.redirect_chains[original_url] = [original_url]

            # Add the new redirect
            self.redirect_chains[original_url].append(redirected_url)

            # Check for loops
            if self.redirect_chains[original_url].count(redirected_url) > 1:
                logger.warning(
                    f"Redirect loop detected for {original_url} -> {redirected_url}"
                )
                return False

            # Check for maximum redirect chain length
            if len(self.redirect_chains[original_url]) > self.max_redirects:
                logger.warning(
                    f"Maximum redirect chain length ({self.max_redirects}) exceeded for {original_url}"
                )
                return False

            return True

    async def get_redirect_chain(self, url):
        """Get the redirect chain for a URL"""
        async with self.lock:
            return self.redirect_chains.get(url, [url])

    async def is_in_redirect_chain(self, chain_url, target_url):
        """Check if target_url is in the redirect chain of chain_url"""
        async with self.lock:
            chain = self.redirect_chains.get(chain_url, [])
            return target_url in chain


# Create a singleton instance to use throughout the application
redirect_tracker = RedirectTracker()


async def fetch_url(session, url, depth, university, url_queue):
    """Fetch a URL and process its content with redirect tracking."""
    # First check if the crawler is still running
    if not await state_manager.is_crawler_running():
        return

    # Normalize URL to handle Unicode
    normalized_url = normalize_url(url)
    if normalized_url != url:
        logger.info(f"Normalized URL: {url} -> {normalized_url}")
        url = normalized_url

    # Start tracking redirects for this URL
    await redirect_tracker.start_tracking(url)

    try:
        # Apply politeness delay
        await asyncio.sleep(Config.REQUEST_DELAY)

        # Log when fetching admission-related domains for debugging
        parsed = urlparse(url)
        domain = parsed.netloc.lower()
        path = parsed.path.lower()

        if (
            "admission" in domain
            or "apply" in domain
            or "undergrad" in domain
            or any(p in path for p in ["/apply", "/admission", "/admissions"])
        ):
            logger.info(f"Fetching admission-related URL: {url} (depth {depth})")

        # Set up headers
        headers = {
            "User-Agent": Config.USER_AGENT,
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
            "Accept-Language": "en-US,en;q=0.5",
            "Connection": "keep-alive",
            "DNT": "1",
        }

        # Use rotating user agents if configured
        if Config.USER_AGENT_ROTATION and Config.USER_AGENTS:
            headers["User-Agent"] = random.choice(Config.USER_AGENTS)

        # Fetch URL with headers
        async with session.get(
            url, timeout=Config.REQUEST_TIMEOUT, allow_redirects=True, headers=headers
        ) as response:
            if response.status != 200:
                logger.warning(f"Got status {response.status} for {url}")
                return

            # Track any redirects that occurred
            if str(response.url) != url:
                logger.info(f"Redirected: {url} -> {response.url}")

                # Normalize the final URL
                final_url = normalize_url(str(response.url))

                # Add to redirect chain
                if not await redirect_tracker.add_redirect(url, final_url):
                    logger.warning(f"Skipping URL due to redirect issues: {url}")
                    return

                # Update the URL to the final redirected URL
                url = final_url

            # Increment visited counter and track domain
            await state_manager.increment_visited_counter()
            await state_manager.increment_domain_count(domain)

            # Use encoding handler to properly decode HTML
            try:
                html = await EncodingHandler.decode_html(response)
            except Exception as e:
                logger.error(f"Error decoding HTML for {url}: {e}")
                return

            # Extract title with encoding awareness
            title = extract_title(html)

            # Check if this is an application page
            is_app_page, reasons = is_application_page(url, html, title)

            if is_app_page:
                logger.success(f"Found application page: {url} - {title}")
                logger.info(f"Reasons: {', '.join(reasons)}")

                await state_manager.add_application_page(
                    {
                        "url": url,
                        "title": title,
                        "university": university["name"],
                        "reasons": reasons,
                        "depth": depth,
                        "html_snippet": html[:5000],  # Save a snippet for evaluation
                    }
                )

            # Check if we're on an admission-related domain to increase depth
            if "admission" in domain or "apply" in domain or "undergrad" in domain:
                # Add to our set of admission domains
                await state_manager.add_admission_domain(domain)

                # Look for specific application links if we're in an admission domain
                apply_links = await find_critical_application_links(url, html)

                # Process these critical links with highest priority (depth doesn't matter)
                for link in apply_links:
                    # Check if this is in a redirect chain to prevent loops
                    if await redirect_tracker.is_in_redirect_chain(url, link):
                        logger.warning(
                            f"Skipping link {link} - already in redirect chain"
                        )
                        continue

                    # Use a high priority value (0) for critical application links
                    await url_queue.put(
                        (0, link, Config.MAX_DEPTH, university)
                    )  # Reset depth to ensure crawling

                # Don't extract more links if we've reached the max admission depth
                if depth <= 0 and depth > -Config.MAX_ADMISSION_DEPTH:
                    logger.info(f"Allowing extended depth for admission URL: {url}")
                    # Continue with negative depth to track extended crawling
                    depth = -1  # Start extended depth crawling
                elif depth < 0 and depth <= -Config.MAX_ADMISSION_DEPTH:
                    return
            # For normal domains, respect the regular depth
            elif depth <= 0:
                return

            # Check URL limit again before extracting links
            if await state_manager.should_enforce_url_limit(Config.MAX_TOTAL_URLS):
                return

            # Extract and queue links
            links = extract_links(url, html)
            await queue_links(links, depth - 1, university, url_queue)

    except aiohttp.ClientError as e:
        logger.error(f"Error fetching {url}: {e}")
    except asyncio.TimeoutError:
        logger.error(f"Timeout fetching {url}")
    except Exception as e:
        logger.error(f"Unexpected error processing {url}: {e}")


async def find_critical_application_links(url, html):
    """Find critical application links in admission-related pages."""
    apply_links = []
    apply_patterns = [
        r'<a[^>]*href=["\'](.*?apply.*?first-year.*?)["\']',
        r'<a[^>]*href=["\'](.*?apply.*?freshman.*?)["\']',
        r'<a[^>]*href=["\'](.*?apply.*?undergraduate.*?)["\']',
        r'<a[^>]*href=["\'](.*?apply.*?transfer.*?)["\']',
        r'<a[^>]*href=["\'](.*?admission.*?apply.*?)["\']',
    ]

    for pattern in apply_patterns:
        matches = re.findall(pattern, html, re.IGNORECASE)
        for href in matches:
            full_url = urljoin(url, href)
            normalized = normalize_url(full_url)

            # Check if this URL has already been visited
            if not await state_manager.is_url_visited(normalized) and is_valid_url(
                normalized
            ):
                logger.info(f"Found critical application link: {normalized}")
                apply_links.append(normalized)

    return apply_links


async def queue_links(links, depth, university, url_queue):
    """Queue links for crawling with redirect cycle detection."""
    # Check URL limit before processing
    if await state_manager.should_enforce_url_limit(Config.MAX_TOTAL_URLS):
        return

    university_domain = university["domain"]
    domain_queue = []

    for link in links:
        # Check if crawler is still running
        if not await state_manager.is_crawler_running():
            return

        parsed = urlparse(link)
        domain = parsed.netloc

        # Skip if we've reached the max URLs for a domain
        domain_counts = await state_manager.get_domain_counts()
        if (
            domain in domain_counts
            and domain_counts[domain] >= Config.MAX_URLS_PER_DOMAIN
        ):
            continue

        # Skip if we've reached the max total URLs
        counters = await state_manager.get_counters()
        if counters["queued"] >= Config.MAX_TOTAL_URLS:
            logger.info(f"Reached maximum total URLs limit ({Config.MAX_TOTAL_URLS})")
            return

        # Check if domain is related to the university
        is_related = False
        if university_domain in domain:
            is_related = True
        elif is_related_domain(university_domain, domain, university["name"]):
            is_related = True

        if not is_related:
            continue

        # Skip if already visited
        if await state_manager.is_url_visited(link):
            continue

        # Skip if it appears to be part of a redirect chain
        redirect_chain = await redirect_tracker.get_redirect_chain(link)
        if len(redirect_chain) > 1:
            logger.debug(f"Skipping {link} - already part of a redirect chain")
            continue

        # Get priority (lower is higher priority)
        priority = get_url_priority(link, university)

        # Add to domain queue
        domain_queue.append((priority, link, depth, university))

    # Queue links
    for priority, link, depth, university in domain_queue:
        await url_queue.put((priority, link, depth, university))



================================================
File: crawler/monitor.py
================================================
"""
Progress monitoring for the crawler
"""

import asyncio
import time
import aiohttp
import re
from loguru import logger

from config import Config
from analysis.page_analyzer import is_application_page, extract_title
from models.state_manager import state_manager  # Correct import for state manager


async def monitor_progress(url_queue):
    """Monitor and report crawler progress."""
    last_time = time.time()
    last_visited = 0

    while await state_manager.is_crawler_running():
        try:
            await asyncio.sleep(5)

            # Get current counters
            counters = await state_manager.get_counters()
            current_time = time.time()
            elapsed = current_time - last_time
            visited_delta = counters["visited"] - last_visited
            rate = visited_delta / elapsed if elapsed > 0 else 0

            # Get application pages count
            application_pages = await state_manager.get_application_pages()

            logger.info(
                f"Progress: {counters['visited']} URLs visited, {url_queue.qsize()} queued, "
                f"{len(application_pages)} application pages found, {rate:.1f} URLs/sec"
            )

            # Log admission domains we've found
            admission_domains = await state_manager.get_admission_domains()
            if admission_domains:
                logger.info(f"Found admission domains: {', '.join(admission_domains)}")

            # Log domains with highest counts
            top_domains = await state_manager.get_top_domains(5)
            if top_domains:
                logger.info(
                    f"Top domains: {', '.join([f'{d}({c})' for d, c in top_domains])}"
                )

            # Check if queue is empty or URL limit reached
            if (url_queue.empty() and counters["visited"] > 0) or counters[
                "queued"
            ] >= Config.MAX_TOTAL_URLS:
                logger.info("Queue is empty or URL limit reached, crawling complete")
                await state_manager.stop_crawler()
                break

            last_time = current_time
            last_visited = counters["visited"]

        except asyncio.CancelledError:
            break
        except Exception as e:
            logger.error(f"Monitor error: {e}")


async def explore_specific_application_paths():
    """Directly check common application paths on found admission domains."""
    admission_domains = await state_manager.get_admission_domains()
    if not admission_domains:
        return

    logger.info(
        f"Exploring specific application paths on {len(admission_domains)} admission domains"
    )

    async with aiohttp.ClientSession() as session:
        for domain in admission_domains:
            # Common application paths to check directly
            specific_paths = [
                "/apply",
                "/apply/",  # With trailing slash
                "/apply/first-year",
                "/apply/first-year/",  # With trailing slash
                "/apply/freshman",
                "/apply/undergraduate",
                "/application",
                "/admission/apply",
                "/admission/first-year",
                "/admission/freshman",
            ]

            for path in specific_paths:
                full_url = f"https://{domain}{path}"
                if await state_manager.is_url_visited(full_url):
                    continue

                await check_direct_application_path(full_url, domain, session, path)


async def check_direct_application_path(full_url, domain, session, current_path=None):
    """Check a specific URL for application content."""
    logger.info(f"Directly checking potential application path: {full_url}")
    try:
        async with session.get(full_url, timeout=Config.REQUEST_TIMEOUT) as response:
            if response.status == 200:
                html = await response.text()
                title = extract_title(html)

                # Skip 404 pages even if they return 200 status
                if "not found" in title.lower():
                    logger.warning(f"Skipping 404 page: {full_url} - {title}")
                    return

                # Check if this is an application page
                is_app_page, reasons = is_application_page(full_url, html, title)
                if is_app_page:
                    logger.success(
                        f"Found direct application path: {full_url} - {title}"
                    )
                    # Add to found applications through state manager
                    for university in Config.SEED_UNIVERSITIES:
                        if university["domain"] in domain:
                            await state_manager.add_application_page(
                                {
                                    "url": full_url,
                                    "title": title,
                                    "university": university["name"],
                                    "reasons": reasons,
                                    "depth": 0,
                                    "html_snippet": html[:5000],
                                }
                            )
                            break

                # If we find a valid /apply path, recursively check its subpaths
                if (
                    current_path
                    and ("/apply" in current_path or current_path.endswith("/apply/"))
                    and "not found" not in title.lower()
                ):
                    university_name = next(
                        (
                            u["name"]
                            for u in Config.SEED_UNIVERSITIES
                            if u["domain"] in domain
                        ),
                        "Unknown University",
                    )
                    await check_subpaths(full_url, university_name, session)

    except Exception as e:
        logger.error(f"Error checking direct path {full_url}: {e}")


async def check_subpaths(base_url, university_name, session):
    """Recursively check subpaths of a valid application URL."""
    logger.info(f"Checking subpaths of {base_url}")

    # Define application subpaths to check
    subpaths = [
        "first-year",
        "first-year/",
        "freshman",
        "freshman/",
        "undergraduate",
        "undergraduate/",
        "transfer",
        "transfer/",
    ]

    for subpath in subpaths:
        if base_url.endswith("/"):
            full_url = f"{base_url}{subpath}"
        else:
            full_url = f"{base_url}/{subpath}"

        if await state_manager.is_url_visited(full_url):
            continue

        # Mark as visited
        await state_manager.add_visited_url(full_url)

        logger.info(f"Checking application subpath: {full_url}")
        try:
            async with session.get(
                full_url, timeout=Config.REQUEST_TIMEOUT
            ) as response:
                if response.status == 200:
                    html = await response.text()
                    title = extract_title(html)

                    # Skip 404 pages
                    if "not found" in title.lower() or "page not found" in html.lower():
                        logger.warning(f"Skipping 404 page: {full_url} - {title}")
                        continue

                    # Check if this is an application page
                    is_app_page, reasons = is_application_page(full_url, html, title)
                    if is_app_page:
                        logger.success(
                            f"Found application subpath: {full_url} - {title}"
                        )
                        # Add to found applications using state manager
                        await state_manager.add_application_page(
                            {
                                "url": full_url,
                                "title": title,
                                "university": university_name,
                                "reasons": reasons,
                                "depth": 0,
                                "html_snippet": html[:5000],
                            }
                        )

                    # Also check for specific keywords in the HTML that might indicate application content
                    if any(
                        term in html.lower()
                        for term in [
                            "application form",
                            "common app",
                            "apply now",
                            "application deadline",
                        ]
                    ):
                        logger.success(
                            f"Found application-related content: {full_url} - {title}"
                        )
                        # Add to found applications if not already added
                        if not is_app_page:
                            await state_manager.add_application_page(
                                {
                                    "url": full_url,
                                    "title": title,
                                    "university": university_name,
                                    "reasons": ["Contains application-related content"],
                                    "depth": 0,
                                    "html_snippet": html[:5000],
                                }
                            )
        except Exception as e:
            logger.error(f"Error checking subpath {full_url}: {e}")



================================================
File: crawler/queue.py
================================================
"""
Priority queue implementation for the crawler
"""

import asyncio
from loguru import logger

from models.state_manager import state_manager
from config import Config


class UniqueURLQueue:
    """A queue that ensures each URL is processed only once with priority support."""

    def __init__(self, maxsize=0):
        self.queue = asyncio.PriorityQueue(maxsize)
        self.url_set = set()
        self.lock = asyncio.Lock()
        self.current_size = 0
        self.max_memory_size = 10000  # Maximum number of items in queue

    async def put(self, item):
        """Put an item in the queue if it's not already there and under the limit."""
        priority, url, depth, university = item

        # First check URL limit before anything else
        if await state_manager.should_enforce_url_limit(Config.MAX_TOTAL_URLS):
            # Don't log every time - this was causing log bloat
            return False

        async with self.lock:
            if url not in self.url_set:
                self.url_set.add(url)

                # Check if queue is getting too large
                if self.current_size >= self.max_memory_size:
                    # Discard the lowest priority (highest number) items
                    logger.warning(
                        f"Queue size limit reached ({self.max_memory_size}), prioritizing high-value URLs"
                    )
                    return False

                # Register URL as visited immediately to prevent duplicates
                await state_manager.add_visited_url(url)

                # Increment queued counter
                await state_manager.increment_queued_counter()

                # Add to queue
                await self.queue.put(item)
                self.current_size += 1
                return True

        return False

    async def get(self):
        """Get an item from the queue."""
        item = await self.queue.get()
        self.current_size -= 1
        return item

    def task_done(self):
        """Mark a task as done."""
        self.queue.task_done()

    async def join(self):
        """Wait for all items to be processed."""
        await self.queue.join()

    def empty(self):
        """Check if the queue is empty."""
        return self.queue.empty()

    def qsize(self):
        """Get the queue size."""
        return self.current_size



================================================
File: crawler/shutdown.py
================================================
"""
Graceful shutdown implementation
"""

import asyncio
import signal
import time
from loguru import logger

# Flag to track shutdown requests
_shutdown_requested = False


class GracefulShutdown:
    """Manages graceful shutdown of worker tasks."""

    def __init__(self):
        self.shutdown_requested = False
        self.shutdown_lock = asyncio.Lock()
        self.active_tasks = set()
        self.task_lock = asyncio.Lock()

    async def request_shutdown(self):
        """Request shutdown of all workers."""
        async with self.shutdown_lock:
            self.shutdown_requested = True
            logger.info("Shutdown requested, waiting for active tasks to complete...")

    async def is_shutdown_requested(self):
        """Check if shutdown has been requested."""
        async with self.shutdown_lock:
            return self.shutdown_requested

    async def register_task(self, task_id, url):
        """Register an active task."""
        async with self.task_lock:
            self.active_tasks.add((task_id, url))

    async def unregister_task(self, task_id, url):
        """Unregister a completed task."""
        async with self.task_lock:
            self.active_tasks.discard((task_id, url))

    async def get_active_tasks(self):
        """Get list of currently active tasks."""
        async with self.task_lock:
            return list(self.active_tasks)

    async def wait_for_completion(self, timeout=30):
        """Wait for all active tasks to complete with timeout."""
        start_time = time.time()
        while True:
            active = await self.get_active_tasks()
            if not active:
                return True

            if time.time() - start_time > timeout:
                logger.warning(
                    f"Shutdown timeout exceeded with {len(active)} tasks still active"
                )
                return False

            logger.info(f"Waiting for {len(active)} active tasks to complete...")
            await asyncio.sleep(1)


# Initialize the global shutdown controller
shutdown_controller = GracefulShutdown()


# Global flag for signal handlers (which are synchronous)
def signal_handler(signum, frame):
    """Synchronous signal handler that sets a global flag."""
    global _shutdown_requested
    logger.info("\nReceived exit signal. Shutting down gracefully...")
    _shutdown_requested = True


async def check_for_shutdown():
    """Async function to check if a shutdown was requested by signal handler."""
    global _shutdown_requested
    if _shutdown_requested:
        _shutdown_requested = False  # Reset flag
        await shutdown_controller.request_shutdown()
        return True
    return False


def setup_signal_handlers():
    """Set up signal handlers for graceful shutdown."""
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)



================================================
File: crawler/worker.py
================================================
"""
Worker implementation for processing URLs from the queue
"""

import asyncio
import time
from loguru import logger

from crawler.shutdown import shutdown_controller
from crawler.fetcher import fetch_url
from models.state_manager import state_manager

from config import Config


async def worker(session, worker_id, url_queue):
    """Worker to process URLs from the queue."""
    logger.info(f"Worker {worker_id} started")

    while await state_manager.is_crawler_running():
        try:
            # Check if shutdown requested
            if await shutdown_controller.is_shutdown_requested():
                logger.info(f"Worker {worker_id} shutting down due to shutdown request")
                break

            # Get URL with timeout to allow for shutdown checks
            try:
                priority, url, depth, university = await asyncio.wait_for(
                    url_queue.get(), timeout=1.0
                )
            except asyncio.TimeoutError:
                continue
            except asyncio.CancelledError:
                break

            # Register this task
            task_id = f"worker-{worker_id}-{time.time()}"
            await shutdown_controller.register_task(task_id, url)

            try:
                # Check URL limit before processing
                counters = await state_manager.get_counters()
                if counters["queued"] >= Config.MAX_TOTAL_URLS:
                    logger.debug(f"Skipping {url} due to URL limit")
                    continue

                # Process URL
                await fetch_url(session, url, depth, university, url_queue)
            finally:
                # Always unregister task when done or on exception
                await shutdown_controller.unregister_task(task_id, url)
                # Mark task as done
                url_queue.task_done()

        except asyncio.CancelledError:
            logger.info(f"Worker {worker_id} cancelled")
            break
        except Exception as e:
            logger.error(f"Worker {worker_id} error: {e}")

    logger.info(f"Worker {worker_id} shutting down")


async def start_workers(session, url_queue, num_workers=None):
    """Start a pool of worker tasks."""

    if num_workers is None:
        num_workers = Config.NUM_WORKERS

    workers = []
    for i in range(num_workers):
        worker_task = asyncio.create_task(worker(session, i, url_queue))
        workers.append(worker_task)

    return workers




================================================
File: database/__init__.py
================================================



================================================
File: database/db_operations.py
================================================
"""
Core database operations for the crawler
"""

import os
import asyncio
import aiosqlite
from loguru import logger

from config import Config

# Database file path
DB_PATH = os.path.join(os.path.dirname(__file__), "..", "crawler_data.db")

# Global connection pool (for reuse)
_connection = None
_connection_lock = asyncio.Lock()


async def get_connection():
    """Get a database connection (reusing existing if available)."""
    global _connection

    if _connection is None:
        async with _connection_lock:
            if _connection is None:
                try:
                    _connection = await aiosqlite.connect(DB_PATH)
                    # Enable foreign keys
                    await _connection.execute("PRAGMA foreign_keys = ON")
                    # For better performance
                    await _connection.execute("PRAGMA journal_mode = WAL")
                except Exception as e:
                    logger.error(f"Error connecting to database: {e}")
                    raise

    return _connection


async def close_connection():
    """Close the database connection."""
    global _connection

    if _connection is not None:
        async with _connection_lock:
            if _connection is not None:
                try:
                    await _connection.close()
                    _connection = None
                except Exception as e:
                    logger.error(f"Error closing database connection: {e}")


async def init_database():
    """Initialize the database schema."""
    if not Config.USE_SQLITE:
        logger.info("SQLite database is disabled in config.")
        return

    try:
        conn = await get_connection()

        # Create tables
        await conn.execute(
            """
        CREATE TABLE IF NOT EXISTS crawl_runs (
            run_id TEXT PRIMARY KEY,
            start_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            end_time TIMESTAMP,
            university TEXT,
            total_urls_visited INTEGER DEFAULT 0,
            total_application_pages INTEGER DEFAULT 0,
            total_actual_applications INTEGER DEFAULT 0,
            status TEXT DEFAULT 'running'
        )
        """
        )

        await conn.execute(
            """
        CREATE TABLE IF NOT EXISTS api_metrics (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            run_id TEXT NOT NULL,
            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            model TEXT,
            prompt_tokens INTEGER DEFAULT 0,
            completion_tokens INTEGER DEFAULT 0,
            total_tokens INTEGER DEFAULT 0,
            pages_evaluated INTEGER DEFAULT 0,
            estimated_cost_usd REAL DEFAULT 0.0,
            FOREIGN KEY (run_id) REFERENCES crawl_runs(run_id)
        )
        """
        )

        await conn.execute(
            """
        CREATE TABLE IF NOT EXISTS application_pages (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            run_id TEXT NOT NULL,
            url TEXT NOT NULL,
            title TEXT,
            university TEXT,
            depth INTEGER,
            is_actual_application INTEGER DEFAULT 0,
            ai_evaluation TEXT,
            found_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (run_id) REFERENCES crawl_runs(run_id)
        )
        """
        )

        # Create indexes for better performance
        await conn.execute(
            "CREATE INDEX IF NOT EXISTS idx_application_pages_run_id ON application_pages(run_id)"
        )
        await conn.execute(
            "CREATE INDEX IF NOT EXISTS idx_api_metrics_run_id ON api_metrics(run_id)"
        )
        await conn.execute(
            "CREATE INDEX IF NOT EXISTS idx_application_pages_url ON application_pages(url)"
        )

        await conn.commit()
        logger.success("Database initialized successfully")

    except Exception as e:
        logger.error(f"Failed to initialize database: {e}")
        raise


async def start_crawl_run(run_id, university):
    """Record the start of a crawl run."""
    if not Config.USE_SQLITE:
        return

    try:
        conn = await get_connection()
        await conn.execute(
            "INSERT INTO crawl_runs (run_id, university) VALUES (?, ?)",
            (run_id, university),
        )
        await conn.commit()
        logger.info(f"Recorded start of crawl run {run_id}")
    except Exception as e:
        logger.error(f"Failed to record crawl run start: {e}")


async def end_crawl_run(run_id, total_urls_visited, total_app_pages, total_actual_apps):
    """Record the end of a crawl run."""
    if not Config.USE_SQLITE:
        return

    try:
        conn = await get_connection()
        await conn.execute(
            """
            UPDATE crawl_runs 
            SET end_time = CURRENT_TIMESTAMP, 
                status = 'completed',
                total_urls_visited = ?,
                total_application_pages = ?,
                total_actual_applications = ?
            WHERE run_id = ?
            """,
            (total_urls_visited, total_app_pages, total_actual_apps, run_id),
        )
        await conn.commit()
        logger.info(f"Recorded end of crawl run {run_id}")
    except Exception as e:
        logger.error(f"Failed to record crawl run end: {e}")



================================================
File: database/metrics_storage.py
================================================
"""
Metrics storage and retrieval functionality
"""

import datetime
from loguru import logger

from database.db_operations import get_connection
from config import Config


async def save_metrics_to_db(metrics, run_id):
    """Save API metrics to the database."""
    if not Config.USE_SQLITE:
        return

    try:
        conn = await get_connection()
        await conn.execute(
            """
            INSERT INTO api_metrics
            (run_id, timestamp, model, prompt_tokens, completion_tokens, 
             total_tokens, pages_evaluated, estimated_cost_usd)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            """,
            (
                run_id,
                metrics.get(
                    "timestamp", datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                ),
                metrics.get("model", Config.MODEL_NAME),
                metrics.get("prompt_tokens", 0),
                metrics.get("completion_tokens", 0),
                metrics.get("total_tokens", 0),
                metrics.get("pages_evaluated", 0),
                metrics.get("estimated_cost_usd", 0.0),
            ),
        )
        await conn.commit()
        logger.info(f"Saved API metrics to database for run {run_id}")
    except Exception as e:
        logger.error(f"Failed to save API metrics: {e}")
        raise


async def save_application_page(page, run_id):
    """Save an application page to the database."""
    if not Config.USE_SQLITE:
        return

    try:
        conn = await get_connection()
        await conn.execute(
            """
            INSERT INTO application_pages
            (run_id, url, title, university, depth, is_actual_application, ai_evaluation)
            VALUES (?, ?, ?, ?, ?, ?, ?)
            """,
            (
                run_id,
                page.get("url", ""),
                page.get("title", ""),
                page.get("university", ""),
                page.get("depth", 0),
                1 if page.get("is_actual_application", False) else 0,
                page.get("ai_evaluation", ""),
            ),
        )
        await conn.commit()
    except Exception as e:
        logger.error(f"Failed to save application page: {e}")


async def save_application_pages(pages, run_id):
    """Save multiple application pages to the database."""
    if not Config.USE_SQLITE or not pages:
        return

    try:
        conn = await get_connection()
        async with conn.cursor() as cursor:
            for page in pages:
                await cursor.execute(
                    """
                    INSERT INTO application_pages
                    (run_id, url, title, university, depth, is_actual_application, ai_evaluation)
                    VALUES (?, ?, ?, ?, ?, ?, ?)
                    """,
                    (
                        run_id,
                        page.get("url", ""),
                        page.get("title", ""),
                        page.get("university", ""),
                        page.get("depth", 0),
                        1 if page.get("is_actual_application", False) else 0,
                        page.get("ai_evaluation", ""),
                    ),
                )
            await conn.commit()
        logger.info(f"Saved {len(pages)} application pages to database")
    except Exception as e:
        logger.error(f"Failed to save application pages: {e}")


async def get_aggregated_metrics(period="month"):
    """Get aggregated API metrics for a specific time period."""
    if not Config.USE_SQLITE:
        return {
            "total_runs": 0,
            "total_pages": 0,
            "total_tokens": 0,
            "total_cost": 0.0,
        }

    try:
        conn = await get_connection()

        # Define date filter based on period
        date_filter = ""
        if period == "day":
            date_filter = "AND timestamp >= datetime('now', '-1 day')"
        elif period == "week":
            date_filter = "AND timestamp >= datetime('now', '-7 days')"
        elif period == "month":
            date_filter = "AND timestamp >= datetime('now', '-30 days')"

        # Query for metrics
        query = f"""
        SELECT 
            COUNT(DISTINCT run_id) as total_runs,
            SUM(pages_evaluated) as total_pages,
            SUM(total_tokens) as total_tokens,
            SUM(estimated_cost_usd) as total_cost
        FROM api_metrics
        WHERE 1=1 {date_filter}
        """

        async with conn.execute(query) as cursor:
            row = await cursor.fetchone()

            if row:
                return {
                    "total_runs": row[0] or 0,
                    "total_pages": row[1] or 0,
                    "total_tokens": row[2] or 0,
                    "total_cost": row[3] or 0.0,
                }
            else:
                return {
                    "total_runs": 0,
                    "total_pages": 0,
                    "total_tokens": 0,
                    "total_cost": 0.0,
                }
    except Exception as e:
        logger.error(f"Failed to get aggregated metrics: {e}")
        # Return empty metrics on error
        return {
            "total_runs": 0,
            "total_pages": 0,
            "total_tokens": 0,
            "total_cost": 0.0,
        }


async def get_recent_application_pages(university=None, limit=10):
    """Get recently found application pages."""
    if not Config.USE_SQLITE:
        return []

    try:
        conn = await get_connection()

        query = """
        SELECT url, title, university, is_actual_application, ai_evaluation, found_timestamp
        FROM application_pages
        """

        params = []
        if university:
            query += " WHERE university = ?"
            params.append(university)

        query += " ORDER BY found_timestamp DESC LIMIT ?"
        params.append(limit)

        async with conn.execute(query, params) as cursor:
            rows = await cursor.fetchall()

            result = []
            for row in rows:
                result.append(
                    {
                        "url": row[0],
                        "title": row[1],
                        "university": row[2],
                        "is_actual_application": bool(row[3]),
                        "ai_evaluation": row[4],
                        "found_timestamp": row[5],
                    }
                )

            return result
    except Exception as e:
        logger.error(f"Failed to get recent application pages: {e}")
        return []




================================================
File: models/__init__.py
================================================



================================================
File: models/application_page.py
================================================
"""
Data model for application pages
"""

from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any, Iterator
from datetime import datetime


@dataclass
class ApplicationPage:
    """Represents a university application page."""

    url: str
    title: str
    university: str
    reasons: List[str] = field(default_factory=list)
    depth: int = 0
    is_actual_application: bool = False
    ai_evaluation: Optional[str] = None
    html_snippet: Optional[str] = None
    found_timestamp: datetime = field(default_factory=datetime.now)
    application_type: str = "information_only"
    category: int = 4  # Default is information_only (category 4)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        result = {
            "url": self.url,
            "title": self.title,
            "university": self.university,
            "reasons": self.reasons,
            "depth": self.depth,
            "is_actual_application": self.is_actual_application,
            "ai_evaluation": self.ai_evaluation,
            "application_type": self.application_type,
            "category": self.category,
            "found_timestamp": self.found_timestamp.isoformat(),
        }

        # Only include html_snippet if it exists
        if self.html_snippet:
            result["html_snippet"] = self.html_snippet

        return result

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ApplicationPage":
        """Create an ApplicationPage from a dictionary."""
        # Handle timestamp conversion
        found_timestamp = data.get("found_timestamp")
        if isinstance(found_timestamp, str):
            try:
                found_timestamp = datetime.fromisoformat(found_timestamp)
            except ValueError:
                found_timestamp = datetime.now()

        return cls(
            url=data.get("url", ""),
            title=data.get("title", ""),
            university=data.get("university", ""),
            reasons=data.get("reasons", []),
            depth=data.get("depth", 0),
            is_actual_application=data.get("is_actual_application", False),
            ai_evaluation=data.get("ai_evaluation"),
            html_snippet=data.get("html_snippet"),
            found_timestamp=found_timestamp or datetime.now(),
            application_type=data.get("application_type", "information_only"),
            category=data.get("category", 4),
        )


class ApplicationPageCollection:
    """Collection of application pages with filtering and grouping capabilities."""

    def __init__(self, pages: List[ApplicationPage] = None):
        self.pages = pages or []

    def __iter__(self) -> Iterator[ApplicationPage]:
        """Make the collection iterable, returning an iterator of pages."""
        return iter(self.pages)

    def __len__(self) -> int:
        """Return the number of pages in the collection."""
        return len(self.pages)

    def add(self, page: ApplicationPage) -> None:
        """Add a page to the collection."""
        self.pages.append(page)

    def filter_actual_applications(self) -> List[ApplicationPage]:
        """Get only the confirmed application pages."""
        return [p for p in self.pages if p.is_actual_application]

    def group_by_university(self) -> Dict[str, List[ApplicationPage]]:
        """Group pages by university."""
        result = {}
        for page in self.pages:
            if page.university not in result:
                result[page.university] = []
            result[page.university].append(page)
        return result

    def to_dict_list(self) -> List[Dict[str, Any]]:
        """Convert to a list of dictionaries for serialization."""
        return [page.to_dict() for page in self.pages]

    def filter_by_category(self, category: int) -> List[ApplicationPage]:
        """Get pages of a specific category."""
        return [p for p in self.pages if p.category == category]

    def filter_by_type(self, app_type: str) -> List[ApplicationPage]:
        """Get pages of a specific application type."""
        return [p for p in self.pages if p.application_type == app_type]

    def get_category_counts(self) -> Dict[int, int]:
        """Count pages by category."""
        counts = {1: 0, 2: 0, 3: 0, 4: 0}
        for page in self.pages:
            if page.category in counts:
                counts[page.category] += 1
        return counts

    @classmethod
    def from_dict_list(cls, data: List[Dict[str, Any]]) -> "ApplicationPageCollection":
        """Create a collection from a list of dictionaries."""
        pages = [ApplicationPage.from_dict(item) for item in data]
        return cls(pages=pages)



================================================
File: models/checkpoint_manager.py
================================================
"""
Checkpoint management for the crawler to support incremental processing.
"""

import os
import json
import asyncio
import time
from datetime import datetime
from typing import List, Dict, Any, Optional

from loguru import logger
from config import Config


class CheckpointManager:
    """
    Manages checkpoints for incremental crawling, evaluation, and results saving.
    """

    def __init__(
        self,
        run_id: str,
        output_dir: str = "outputs",
        checkpoint_interval: int = 60,
        min_batch_size: int = 10,
        max_batch_size: int = 30,
    ):
        """
        Initialize the checkpoint manager.

        Args:
            run_id: Unique identifier for this crawler run
            output_dir: Directory to save checkpoints
            checkpoint_interval: Time between checkpoints in seconds
            min_batch_size: Minimum application pages to trigger batch processing
            max_batch_size: Maximum batch size for evaluation
        """
        self.run_id = run_id
        self.checkpoint_dir = os.path.join(output_dir, "checkpoints", run_id)
        self.checkpoint_interval = checkpoint_interval
        self.min_batch_size = min_batch_size
        self.max_batch_size = max_batch_size

        # Create checkpoint directory
        os.makedirs(self.checkpoint_dir, exist_ok=True)

        # Track state
        self.last_checkpoint_time = time.time()
        self.pending_applications = []
        self.evaluated_applications = []
        self.lock = asyncio.Lock()

        # Create run info file
        self._save_run_info()

        logger.info(f"Checkpoint manager initialized for run {run_id}")
        logger.info(f"Checkpoints will be saved to {self.checkpoint_dir}")

    def _save_run_info(self):
        """Save basic run information to help with recovery."""
        info = {
            "run_id": self.run_id,
            "start_time": datetime.now().isoformat(),
            "checkpoint_interval": self.checkpoint_interval,
            "min_batch_size": self.min_batch_size,
            "max_batch_size": self.max_batch_size,
            "config": {
                "model": Config.MODEL_NAME,
                "max_depth": Config.MAX_DEPTH,
                "max_urls": Config.MAX_TOTAL_URLS,
                "workers": Config.NUM_WORKERS,
            },
        }

        with open(os.path.join(self.checkpoint_dir, "run_info.json"), "w") as f:
            json.dump(info, f, indent=2)

    async def add_application_page(self, page: Dict[str, Any]) -> bool:
        """
        Add an application page to the pending queue.

        Returns:
            bool: True if checkpoint processing was triggered
        """
        async with self.lock:
            self.pending_applications.append(page)

            # Check if we should process a batch
            return await self.should_process_batch()

    async def should_process_batch(self) -> bool:
        """
        Check if we should process a batch of applications.

        Returns:
            bool: True if we should process a batch
        """
        # Check if we have enough pages and enough time has passed
        if len(self.pending_applications) >= self.min_batch_size:
            if len(self.pending_applications) >= self.max_batch_size:
                logger.info(
                    f"Checkpoint triggered: reached max batch size ({self.max_batch_size})"
                )
                return True

            if time.time() - self.last_checkpoint_time >= self.checkpoint_interval:
                logger.info(
                    f"Checkpoint triggered: interval reached ({self.checkpoint_interval}s)"
                )
                return True

        return False

    async def get_batch_for_processing(self) -> List[Dict[str, Any]]:
        """
        Get a batch of application pages for processing.

        Returns:
            List of application pages to process
        """
        async with self.lock:
            # Get up to max_batch_size pages
            batch_size = min(len(self.pending_applications), self.max_batch_size)
            if batch_size == 0:
                return []

            batch = self.pending_applications[:batch_size]

            # Remove the batch from pending applications
            self.pending_applications = self.pending_applications[batch_size:]

            # Update checkpoint time
            self.last_checkpoint_time = time.time()

            return batch

    async def add_evaluated_applications(self, applications: List[Dict[str, Any]]):
        """Add evaluated application pages."""
        async with self.lock:
            self.evaluated_applications.extend(applications)

            # Save the checkpoint
            await self.save_checkpoint()

    async def save_checkpoint(self):
        """Save the current state to a checkpoint file."""
        try:
            # Create a timestamp for the checkpoint
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

            # Save pending applications
            if self.pending_applications:
                with open(
                    os.path.join(self.checkpoint_dir, f"pending_{timestamp}.json"), "w"
                ) as f:
                    json.dump(self.pending_applications, f)

            # Save evaluated applications
            if self.evaluated_applications:
                # Save the latest batch
                with open(
                    os.path.join(self.checkpoint_dir, f"evaluated_{timestamp}.json"),
                    "w",
                ) as f:
                    json.dump(self.evaluated_applications, f)

                # Save cumulative results
                with open(
                    os.path.join(self.checkpoint_dir, "evaluated_all.json"), "w"
                ) as f:
                    json.dump(self.evaluated_applications, f)

                # Generate a new checkpoint report
                try:
                    from output.how_to_apply_report import generate_how_to_apply_report

                    report_file = os.path.join(
                        self.checkpoint_dir, f"how_to_apply_{timestamp}.md"
                    )
                    generate_how_to_apply_report(
                        self.evaluated_applications, report_file, detailed=False
                    )
                    logger.info(f"Generated checkpoint report: {report_file}")
                except Exception as e:
                    logger.warning(f"Could not generate checkpoint report: {e}")

            logger.success(f"Saved checkpoint at {timestamp}")

            return timestamp
        except Exception as e:
            logger.error(f"Error saving checkpoint: {e}")
            return None

    async def save_crawler_state(self, state_manager):
        """
        Save the current crawler state for possible resume.

        Args:
            state_manager: The crawler's state manager instance
        """
        try:
            # Get state data to save
            counters = await state_manager.get_counters()
            domain_counts = await state_manager.get_domain_counts()
            admission_domains = await state_manager.get_admission_domains()

            # Create state object
            state = {
                "timestamp": datetime.now().isoformat(),
                "counters": counters,
                "domain_counts": domain_counts,
                "admission_domains": list(admission_domains),
            }

            # Save state to file
            with open(
                os.path.join(self.checkpoint_dir, "crawler_state.json"), "w"
            ) as f:
                json.dump(state, f, indent=2)

            logger.debug("Saved crawler state")
        except Exception as e:
            logger.error(f"Error saving crawler state: {e}")

    def get_all_evaluated_applications(self) -> List[Dict[str, Any]]:
        """Get all evaluated applications."""
        return self.evaluated_applications

    def get_stats(self) -> Dict[str, Any]:
        """Get checkpoint stats."""
        return {
            "pending_applications": len(self.pending_applications),
            "evaluated_applications": len(self.evaluated_applications),
            "last_checkpoint_time": self.last_checkpoint_time,
            "time_since_checkpoint": time.time() - self.last_checkpoint_time,
        }



================================================
File: models/crawl_stats.py
================================================
"""
Statistics tracking model for the crawler
"""

from dataclasses import dataclass, field
from typing import Dict, Set, List, Optional, Any
from datetime import datetime
import time

from config import Config
from models.application_page import ApplicationPage, ApplicationPageCollection


@dataclass
class CrawlStats:
    """Statistics for a crawl session."""

    # Timing stats
    start_time: float = field(default_factory=time.time)
    last_checkpoint_time: float = field(default_factory=time.time)

    # URL counters
    total_urls_visited: int = 0
    total_urls_queued: int = 0

    # Domain tracking
    domain_visit_counts: Dict[str, int] = field(default_factory=dict)
    admission_related_domains: Set[str] = field(default_factory=set)

    # Page tracking
    application_pages: ApplicationPageCollection = field(
        default_factory=ApplicationPageCollection
    )
    evaluated_pages: ApplicationPageCollection = field(
        default_factory=ApplicationPageCollection
    )

    def update_checkpoint(self) -> None:
        """Update the checkpoint time."""
        self.last_checkpoint_time = time.time()

    def elapsed_since_start(self) -> float:
        """Get elapsed time since start in seconds."""
        return time.time() - self.start_time

    def elapsed_since_checkpoint(self) -> float:
        """Get elapsed time since last checkpoint in seconds."""
        return time.time() - self.last_checkpoint_time

    def current_crawl_rate(self, urls_since_checkpoint: int) -> float:
        """Calculate the current crawl rate in URLs/second."""
        elapsed = self.elapsed_since_checkpoint()
        if elapsed <= 0:
            return 0
        return urls_since_checkpoint / elapsed

    def add_domain_visit(self, domain: str) -> None:
        """Increment the visit count for a domain."""
        if domain not in self.domain_visit_counts:
            self.domain_visit_counts[domain] = 0
        self.domain_visit_counts[domain] += 1

        # Check if we've reached the max URLs for a domain
        if self.domain_visit_counts[domain] >= Config.MAX_URLS_PER_DOMAIN:
            return False
        return True

    def add_admission_domain(self, domain: str) -> None:
        """Add an admission-related domain."""
        self.admission_related_domains.add(domain)

    def add_application_page(self, page_data: Dict[str, Any]) -> None:
        """Add a found application page."""
        page = ApplicationPage.from_dict(page_data)
        self.application_pages.add(page)

    def add_evaluated_page(self, page_data: Dict[str, Any]) -> None:
        """Add an evaluated application page."""
        page = ApplicationPage.from_dict(page_data)
        self.evaluated_pages.add(page)

    def get_top_domains(self, limit: int = 5) -> List[tuple]:
        """Get the top visited domains."""
        return sorted(
            self.domain_visit_counts.items(), key=lambda x: x[1], reverse=True
        )[:limit]

    def should_enforce_url_limit(self) -> bool:
        """Check if we should enforce the URL limit."""
        return self.total_urls_queued >= Config.MAX_TOTAL_URLS


@dataclass
class APIMetrics:
    """Tracking for API usage metrics."""

    prompt_tokens: int = 0
    completion_tokens: int = 0
    total_tokens: int = 0
    estimated_cost_usd: float = 0.0
    pages_evaluated: int = 0
    timestamp: datetime = field(default_factory=datetime.now)
    model: Optional[str] = None
    university: Optional[str] = None

    def add_usage(
        self, prompt_tokens: int, completion_tokens: int, cached_tokens: int = 0
    ) -> None:
        """Add API usage for a request."""
        self.prompt_tokens += prompt_tokens
        self.completion_tokens += completion_tokens
        self.total_tokens += prompt_tokens + completion_tokens
        self.pages_evaluated += 1

        # Get token rates from Config instead of hardcoding
        rate_per_1k_input = Config.PROMPT_TOKEN_COST
        rate_per_1k_completion = Config.COMPLETION_TOKEN_COST
        rate_per_1k_cached_input = Config.CACHED_TOKEN_COST

        request_cost = (
            (prompt_tokens / 1000) * rate_per_1k_input
            + (cached_tokens / 1000) * rate_per_1k_cached_input
            + (completion_tokens / 1000) * rate_per_1k_completion
        )

        self.estimated_cost_usd += request_cost

    def to_dict(self) -> Dict:
        """Convert to dictionary for serialization."""
        return {
            "prompt_tokens": self.prompt_tokens,
            "completion_tokens": self.completion_tokens,
            "total_tokens": self.total_tokens,
            "estimated_cost_usd": self.estimated_cost_usd,
            "pages_evaluated": self.pages_evaluated,
            "timestamp": self.timestamp.isoformat(),
            "model": self.model,
            "university": self.university,
        }



================================================
File: models/state_manager.py
================================================
"""
State manager to handle shared crawler state with proper synchronization
"""

import asyncio
from typing import Dict, Set, List, Any
from loguru import logger


class CrawlerState:
    """Thread-safe state manager for the crawler."""

    def __init__(self):
        # URL tracking
        self.visited_urls = set()
        self.total_urls_visited = 0
        self.total_urls_queued = 0

        # Domain tracking
        self.domain_visit_counts = {}
        self.admission_related_domains = set()

        # Application pages
        self.found_applications = []
        self.evaluated_applications = []

        # Runtime control
        self.crawler_running = True

        # Locks for thread safety
        self.url_counter_lock = asyncio.Lock()
        self.visited_urls_lock = asyncio.Lock()
        self.domain_lock = asyncio.Lock()
        self.applications_lock = asyncio.Lock()
        self.admission_domains_lock = asyncio.Lock()
        self.crawler_status_lock = asyncio.Lock()

    # URL tracking methods
    async def add_visited_url(self, url: str) -> None:
        """Add a URL to the visited set with proper locking."""
        async with self.visited_urls_lock:
            self.visited_urls.add(url)

    async def is_url_visited(self, url: str) -> bool:
        """Check if a URL has been visited with proper locking."""
        async with self.visited_urls_lock:
            return url in self.visited_urls

    async def increment_visited_counter(self) -> int:
        """Increment the visited URLs counter with proper locking."""
        async with self.url_counter_lock:
            self.total_urls_visited += 1
            return self.total_urls_visited

    async def increment_queued_counter(self) -> int:
        """Increment the queued URLs counter with proper locking."""
        async with self.url_counter_lock:
            self.total_urls_queued += 1
            return self.total_urls_queued

    async def get_counters(self) -> Dict[str, int]:
        """Get the current counter values with proper locking."""
        async with self.url_counter_lock:
            return {
                "visited": self.total_urls_visited,
                "queued": self.total_urls_queued,
            }

    # Domain tracking methods
    async def increment_domain_count(self, domain: str) -> int:
        """Increment the count for a domain with proper locking."""
        async with self.domain_lock:
            if domain not in self.domain_visit_counts:
                self.domain_visit_counts[domain] = 0
            self.domain_visit_counts[domain] += 1
            return self.domain_visit_counts[domain]

    async def get_domain_counts(self) -> Dict[str, int]:
        """Get the current domain visit counts with proper locking."""
        async with self.domain_lock:
            return self.domain_visit_counts.copy()

    async def get_top_domains(self, limit: int = 5) -> List[tuple]:
        """Get the top visited domains with proper locking."""
        async with self.domain_lock:
            return sorted(
                self.domain_visit_counts.items(), key=lambda x: x[1], reverse=True
            )[:limit]

    # Application tracking methods
    async def add_application_page(self, page: Dict[str, Any]) -> None:
        """Add a found application page with proper locking."""
        async with self.applications_lock:
            self.found_applications.append(page)

    async def add_evaluated_page(self, page: Dict[str, Any]) -> None:
        """Add an evaluated application page with proper locking."""
        async with self.applications_lock:
            self.evaluated_applications.append(page)

    async def get_application_pages(self) -> List[Dict[str, Any]]:
        """Get the current application pages with proper locking."""
        async with self.applications_lock:
            return self.found_applications.copy()

    async def get_evaluated_pages(self) -> List[Dict[str, Any]]:
        """Get the evaluated application pages with proper locking."""
        async with self.applications_lock:
            return self.evaluated_applications.copy()

    # Admission domains tracking
    async def add_admission_domain(self, domain: str) -> None:
        """Add an admission-related domain with proper locking."""
        async with self.admission_domains_lock:
            self.admission_related_domains.add(domain)

    async def get_admission_domains(self) -> Set[str]:
        """Get the current admission domains with proper locking."""
        async with self.admission_domains_lock:
            return self.admission_related_domains.copy()

    # Crawler control methods
    async def stop_crawler(self) -> None:
        """Signal the crawler to stop with proper locking."""
        async with self.crawler_status_lock:
            self.crawler_running = False
            logger.info("Crawler stop requested")

    async def is_crawler_running(self) -> bool:
        """Check if the crawler is running with proper locking."""
        async with self.crawler_status_lock:
            return self.crawler_running

    # URL limit checking
    async def should_enforce_url_limit(self, limit: int) -> bool:
        """Check if we should enforce the URL limit with proper locking."""
        async with self.url_counter_lock:
            return self.total_urls_queued >= limit


# Create a global state manager instance
state_manager = CrawlerState()








================================================
File: output/__init__.py
================================================



================================================
File: output/exporter.py
================================================
"""
Exporter for crawler results
"""

import os
import json
import csv
from datetime import datetime
from typing import List, Dict, Tuple, Optional, Any

from loguru import logger
from models.application_page import ApplicationPage, ApplicationPageCollection
from output.how_to_apply_report import (
    generate_how_to_apply_report,
    export_how_to_apply_csv,
)


def save_results(
    found_applications: List[Dict],
    evaluated_applications: Optional[List[Dict]] = None,
    api_metrics: Optional[Dict] = None,
    output_dir: str = "outputs",
) -> Tuple[str, Optional[str], Optional[str]]:
    """Save crawler results to JSON files and generate summary."""
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

    # Ensure output directory exists
    os.makedirs(output_dir, exist_ok=True)

    # Convert to ApplicationPage collection and save original results
    original_collection = ApplicationPageCollection.from_dict_list(found_applications)
    original_filename = os.path.join(output_dir, f"application_pages_{timestamp}.json")
    with open(original_filename, "w") as f:
        json.dump(original_collection.to_dict_list(), f, indent=2)

    logger.info(f"Original results saved to {original_filename}")

    # Save evaluated results if available
    evaluated_filename = None
    summary_file = None

    if evaluated_applications:
        # Convert to ApplicationPage collection
        evaluated_collection = ApplicationPageCollection.from_dict_list(
            evaluated_applications
        )

        evaluated_filename = os.path.join(
            output_dir, f"evaluated_applications_{timestamp}.json"
        )
        with open(evaluated_filename, "w") as f:
            json.dump(evaluated_collection.to_dict_list(), f, indent=2)

        logger.info(f"Evaluated results saved to {evaluated_filename}")

        # Generate summary report
        summary_file = os.path.join(output_dir, f"summary_{timestamp}.txt")
        generate_summary_report(evaluated_collection, summary_file, api_metrics)

        logger.info(f"Summary saved to {summary_file}")

    return original_filename, evaluated_filename, summary_file


def generate_summary_report(
    evaluated_applications: List[Dict],
    output_file: str,
    api_metrics: Optional[Dict] = None,
) -> None:
    """Generate a summary report of the findings with categorization."""

    # Handle both dictionaries and ApplicationPage objects
    def get_value(app, field, default=None):
        if isinstance(app, dict):
            return app.get(field, default)
        else:
            return getattr(app, field, default)

    # Count by category
    category_counts = {
        "direct_application": 0,
        "application_instructions": 0,
        "external_application_reference": 0,
        "information_only": 0,
    }

    for app in evaluated_applications:
        app_type = get_value(app, "application_type", "information_only")
        if app_type in category_counts:
            category_counts[app_type] += 1

    # Get unique universities visited
    universities_visited = list(
        set(get_value(app, "university") for app in evaluated_applications)
    )

    # Group by university
    by_university = {}
    for app in evaluated_applications:
        univ = get_value(app, "university")
        if univ not in by_university:
            by_university[univ] = []
        by_university[univ].append(app)

    with open(output_file, "w") as f:
        # Add API metrics if available
        if api_metrics:
            f.write("=== API Usage Metrics ===\n\n")
            f.write(f"Model: {api_metrics.get('model', 'Unknown')}\n")
            f.write(f"Pages evaluated: {api_metrics.get('pages_evaluated', 0)}\n")
            f.write(f"Prompt tokens: {api_metrics.get('prompt_tokens', 0)}\n")
            f.write(f"Completion tokens: {api_metrics.get('completion_tokens', 0)}\n")
            f.write(f"Total tokens: {api_metrics.get('total_tokens', 0)}\n")
            f.write(
                f"Estimated cost: ${api_metrics.get('estimated_cost_usd', 0.0):.4f} USD\n\n"
            )

        # Main summary
        f.write("=== University Application Pages Summary ===\n\n")
        f.write(f"Universities Visited: {', '.join(universities_visited)}\n")
        f.write(f"Total application pages found: {len(evaluated_applications)}\n")

        # Breakdown by category
        f.write("\n=== Pages by Category ===\n")
        f.write(f"Direct Application Pages: {category_counts['direct_application']}\n")
        f.write(
            f"Application Instructions Pages: {category_counts['application_instructions']}\n"
        )
        f.write(
            f"External Application References: {category_counts['external_application_reference']}\n"
        )
        f.write(f"Information Only Pages: {category_counts['information_only']}\n\n")

        # Details by university
        for univ, apps in by_university.items():
            f.write(f"== {univ}: {len(apps)} application pages ==\n")

            # Group by category for this university
            categories = {
                "direct_application": [],
                "application_instructions": [],
                "external_application_reference": [],
                "information_only": [],
            }

            for app in apps:
                app_type = get_value(app, "application_type", "information_only")
                if app_type in categories:
                    categories[app_type].append(app)

            # Direct application pages
            if categories["direct_application"]:
                f.write("\n--- DIRECT APPLICATION PAGES ---\n")
                for i, app in enumerate(categories["direct_application"], 1):
                    f.write(
                        f"{i}. {get_value(app, 'title')}\n   {get_value(app, 'url')}\n   Evaluation: {get_value(app, 'ai_evaluation')}\n\n"
                    )

            # Application instructions
            if categories["application_instructions"]:
                f.write("\n--- APPLICATION INSTRUCTIONS PAGES ---\n")
                for i, app in enumerate(categories["application_instructions"], 1):
                    f.write(
                        f"{i}. {get_value(app, 'title')}\n   {get_value(app, 'url')}\n   Evaluation: {get_value(app, 'ai_evaluation')}\n\n"
                    )

            # External application references
            if categories["external_application_reference"]:
                f.write("\n--- EXTERNAL APPLICATION REFERENCES ---\n")
                for i, app in enumerate(
                    categories["external_application_reference"], 1
                ):
                    f.write(
                        f"{i}. {get_value(app, 'title')}\n   {get_value(app, 'url')}\n   Evaluation: {get_value(app, 'ai_evaluation')}\n\n"
                    )

            # Information only pages
            if categories["information_only"]:
                f.write("\n--- INFORMATION ONLY PAGES ---\n")
                for i, app in enumerate(categories["information_only"], 1):
                    f.write(
                        f"{i}. {get_value(app, 'title')}\n   {get_value(app, 'url')}\n   Evaluation: {get_value(app, 'ai_evaluation')}\n\n"
                    )


def export_to_csv(applications: List[Any], output_file: str) -> None:
    """Export application pages to CSV format with categorization."""
    # Define fields to include
    fields = [
        "url",
        "title",
        "university",
        "is_actual_application",
        "application_type",
        "category",
        "ai_evaluation",
        "depth",
    ]

    with open(output_file, "w", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, fieldnames=fields)
        writer.writeheader()

        for app in applications:
            # Handle both dictionaries and ApplicationPage objects
            if isinstance(app, dict):
                # Create a row with just the fields we want
                row = {field: app.get(field, "") for field in fields}
            else:
                # It's an ApplicationPage object
                row = {field: getattr(app, field, "") for field in fields}

            # Convert boolean to string value
            if "is_actual_application" in row:
                row["is_actual_application"] = (
                    "Yes" if row["is_actual_application"] else "No"
                )

            # Convert category number to a more readable form if it's an integer
            if "category" in row and isinstance(row["category"], int):
                category_map = {
                    1: "Direct Application",
                    2: "Instructions",
                    3: "External Reference",
                    4: "Information Only",
                }
                row["category"] = category_map.get(row["category"], row["category"])

            writer.writerow(row)

    logger.info(f"Exported {len(applications)} application pages to {output_file}")


def update_metrics_in_summary(
    summary_file: str, api_metrics: Dict, historical_metrics: Optional[Dict] = None
) -> None:
    """Add or update API metrics in an existing summary file."""
    if not os.path.exists(summary_file):
        logger.warning(f"Summary file {summary_file} does not exist")
        return

    # Create a temporary file with metrics
    temp_metrics_file = f"temp_metrics_{datetime.now().strftime('%Y%m%d%H%M%S')}.txt"
    try:
        with open(temp_metrics_file, "w") as f:
            f.write("=== API Usage Metrics ===\n\n")
            f.write(f"Model: {api_metrics.get('model', 'Unknown')}\n")
            f.write(f"Pages evaluated: {api_metrics.get('pages_evaluated', 0)}\n")
            f.write(f"Prompt tokens: {api_metrics.get('prompt_tokens', 0)}\n")
            f.write(f"Completion tokens: {api_metrics.get('completion_tokens', 0)}\n")
            f.write(f"Total tokens: {api_metrics.get('total_tokens', 0)}\n")
            f.write(
                f"Estimated cost: ${api_metrics.get('estimated_cost_usd', 0.0):.4f} USD\n\n"
            )

            # Add historical metrics if available
            if historical_metrics:
                f.write("=== Historical API Usage (Last 30 Days) ===\n\n")
                f.write(f"Total runs: {historical_metrics.get('total_runs', 0)}\n")
                f.write(
                    f"Total pages evaluated: {historical_metrics.get('total_pages', 0)}\n"
                )
                f.write(
                    f"Total tokens used: {historical_metrics.get('total_tokens', 0)}\n"
                )
                f.write(
                    f"Total estimated cost: ${historical_metrics.get('total_cost', 0.0):.4f} USD\n\n"
                )

        # Now combine the metrics file with the original summary
        with open(summary_file, "r") as original:
            original_content = original.read()

        with open(summary_file, "w") as final:
            with open(temp_metrics_file, "r") as metrics:
                metrics_content = metrics.read()
            final.write(metrics_content)
            final.write(original_content)

        # Remove the temporary file
        os.remove(temp_metrics_file)

        logger.success(f"Added API metrics to summary file {summary_file}")
    except Exception as e:
        logger.error(f"Failed to write API metrics to summary file: {e}")

        # Clean up temp file if it exists
        if os.path.exists(temp_metrics_file):
            try:
                os.remove(temp_metrics_file)
            except:
                pass


def save_how_to_apply_report(
    evaluated_applications, output_dir="outputs", detailed=False
):
    """
    Generate and save a focused 'How to Apply' report

    Args:
        evaluated_applications: List of evaluated application pages
        output_dir: Directory to save the report
        detailed: Whether to include detailed analysis

    Returns:
        tuple: Paths to the generated report files (markdown, csv)
    """

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

    # Ensure output directory exists
    os.makedirs(output_dir, exist_ok=True)

    # Generate markdown report
    md_file = os.path.join(output_dir, f"how_to_apply_{timestamp}.md")
    generate_how_to_apply_report(evaluated_applications, md_file, detailed=detailed)

    # Generate CSV
    csv_file = os.path.join(output_dir, f"how_to_apply_{timestamp}.csv")
    export_how_to_apply_csv(evaluated_applications, csv_file)

    logger.success(f"How to Apply reports saved to {output_dir}")
    return md_file, csv_file



================================================
File: output/how_to_apply_report.py
================================================
"""
Improved report generator focused on undergraduate applications with special case handling
"""

import os
import csv
import re
from datetime import datetime
from typing import List, Dict, Optional
from urllib.parse import urlparse

from loguru import logger
from output.special_cases import (
    EXTERNAL_APPLICATION_SYSTEMS,
    get_special_case_for_university,
    get_special_case_for_domain,
    is_undergraduate_page,
)


def detect_external_system(page):
    """
    Detect which external application system is mentioned in the page.

    Args:
        page: The application page dictionary

    Returns:
        dict or None: Information about the detected external system
    """
    university_name = page.get("university", "")
    url = page.get("url", "")

    # First check if there's a special case for this university
    special_case = get_special_case_for_university(university_name)
    if special_case:
        system_key = special_case.get("system")
        if system_key and system_key in EXTERNAL_APPLICATION_SYSTEMS:
            return {
                "system": system_key,
                "name": EXTERNAL_APPLICATION_SYSTEMS[system_key]["name"],
                "url": special_case.get(
                    "application_portal",
                    EXTERNAL_APPLICATION_SYSTEMS[system_key]["url"],
                ),
                "note": special_case.get("note", ""),
                "institution_code": special_case.get("institution_code", ""),
            }

    # Then check if there's a special case for the domain
    domain_case = get_special_case_for_domain(url)
    if domain_case:
        system_key = domain_case.get("system")
        if system_key and system_key in EXTERNAL_APPLICATION_SYSTEMS:
            return {
                "system": system_key,
                "name": EXTERNAL_APPLICATION_SYSTEMS[system_key]["name"],
                "url": domain_case.get(
                    "application_portal",
                    EXTERNAL_APPLICATION_SYSTEMS[system_key]["url"],
                ),
                "note": domain_case.get("note", ""),
            }

    # Check for detected external systems from AI evaluation
    if "detected_external_systems" in page:
        for system in page["detected_external_systems"]:
            if system in EXTERNAL_APPLICATION_SYSTEMS:
                return {
                    "system": system,
                    "name": EXTERNAL_APPLICATION_SYSTEMS[system]["name"],
                    "url": EXTERNAL_APPLICATION_SYSTEMS[system]["url"],
                    "description": EXTERNAL_APPLICATION_SYSTEMS[system].get(
                        "description", ""
                    ),
                }

    # Check for external application systems in external_application_systems
    if "external_application_systems" in page and page["external_application_systems"]:
        systems = page["external_application_systems"]
        if systems and len(systems) > 0:
            system_name = systems[0].get("system_name", "").lower()
            # Try to map to our standardized systems
            for key, info in EXTERNAL_APPLICATION_SYSTEMS.items():
                if key.lower() in system_name or info["name"].lower() in system_name:
                    return {
                        "system": key,
                        "name": info["name"],
                        "url": info["url"],
                        "description": info.get("description", ""),
                    }

            # If no match, just return what we have
            return {
                "system": systems[0].get("system_name", ""),
                "name": systems[0].get("system_name", ""),
                "url": systems[0].get("base_url", ""),
            }

    # Check AI evaluation text for mentions of systems
    if "ai_evaluation" in page:
        evaluation = page["ai_evaluation"].lower()

        # Look for mentions of major application systems
        for system, info in EXTERNAL_APPLICATION_SYSTEMS.items():
            # Create a more specific pattern to avoid false positives
            system_name = info["name"].lower()
            if system in evaluation or system_name in evaluation:
                return {
                    "system": system,
                    "name": info["name"],
                    "url": info["url"],
                    "description": info.get("description", ""),
                }

    # No external system detected
    return None


def find_best_application_page(pages, university_name):
    """
    Find the best application page for a university, prioritizing undergraduate pages.

    Args:
        pages: List of application pages for the university
        university_name: Name of the university

    Returns:
        dict: Best application page
    """
    # Filter for undergraduate pages only
    undergrad_pages = [p for p in pages if is_undergraduate_page(p)]
    if not undergrad_pages:
        return None

    # Prioritize actual application pages
    actual_apps = [p for p in undergrad_pages if p.get("is_actual_application", False)]
    if not actual_apps:
        return undergrad_pages[
            0
        ]  # Return any undergraduate page if no actual app pages

    # Priority based on URL patterns
    priority_patterns = [
        "/apply/first-year",
        "/apply/freshman",
        "/apply/undergraduate",
        "/apply/transfer",
        "/admission/apply",
        "/admissions/apply",
        "/apply$",
        "/apply/$",
    ]

    for pattern in priority_patterns:
        for page in actual_apps:
            url = page.get("url", "")
            if re.search(pattern, url):
                return page

    # If no priority match, return first actual application page
    return actual_apps[0]


def generate_how_to_apply_report(evaluated_applications, output_file, detailed=False):
    """
    Generate a clear, focused report on how to apply to each university for undergraduate programs.

    Args:
        evaluated_applications: List of evaluated application pages
        output_file: Path to save the report
        detailed: Whether to include detailed analysis (default: False)

    Returns:
        str: Path to the generated report
    """
    # Filter out graduate-specific application pages
    undergrad_applications = [
        a for a in evaluated_applications if is_undergraduate_page(a)
    ]

    # Group applications by university
    universities = {}
    for app in undergrad_applications:
        univ_name = app.get("university", "Unknown University")
        if univ_name not in universities:
            universities[univ_name] = []
        universities[univ_name].append(app)

    with open(output_file, "w") as f:
        f.write("# HOW TO APPLY - UNIVERSITY UNDERGRADUATE APPLICATION GUIDE\n\n")
        f.write(f"Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
        f.write("## Table of Contents\n\n")

        # Generate table of contents
        for univ_name in sorted(universities.keys()):
            f.write(
                f"- [{univ_name}](#{univ_name.lower().replace(' ', '-').replace(',', '').replace('(', '').replace(')', '')})\n"
            )

        f.write("\n---\n\n")

        # Process each university
        for univ_name in sorted(universities.keys()):
            apps = universities[univ_name]

            # Find the best application page
            best_app = find_best_application_page(apps, univ_name)

            if not best_app:
                continue  # Skip if no undergraduate page found

            # Detect external application system
            external_system = detect_external_system(best_app)

            # Write university section
            f.write(f"## {univ_name}\n\n")

            # Write summary recommendation
            f.write("### How to Apply\n\n")

            if external_system:
                # University uses external application system
                f.write(
                    f"**Application Method**: External application system ({external_system['name']})\n\n"
                )
                f.write(
                    f"**Reference Page**: [{best_app.get('title', 'Application Information')}]({best_app.get('url')})\n\n"
                )
                f.write(
                    f"**External Application Portal**: [{external_system['name']}]({external_system['url']})\n\n"
                )

                if (
                    "institution_code" in external_system
                    and external_system["institution_code"]
                ):
                    f.write(
                        f"**Institution Code**: {external_system['institution_code']}\n\n"
                    )

                if "note" in external_system and external_system["note"]:
                    f.write(f"**Note**: {external_system['note']}\n\n")

                f.write(
                    f"Apply through {external_system['name']} at [{external_system['url']}]({external_system['url']}). Visit the reference page for specific requirements and deadlines.\n\n"
                )
            else:
                # University has its own application portal
                f.write(
                    f"**Application Method**: Direct application through university portal\n\n"
                )
                f.write(
                    f"**Application Link**: [{best_app.get('title', 'Application Portal')}]({best_app.get('url')})\n\n"
                )

                # Extract domain for clarity
                domain = urlparse(best_app.get("url")).netloc
                f.write(
                    f"Apply directly through the university's application portal at {domain}.\n\n"
                )

            # Add any explanation from AI
            if "ai_evaluation" in best_app and best_app["ai_evaluation"]:
                f.write(f"**Details**: {best_app['ai_evaluation']}\n\n")

            # Additional resources section
            if detailed:
                f.write("### Additional Resources\n\n")

                # List direct application portals
                direct_apps = [
                    a
                    for a in apps
                    if a.get("application_type") == "direct_application"
                    and a.get("is_actual_application", False)
                ]

                if direct_apps:
                    f.write("#### Direct Application Portals\n\n")
                    for app in direct_apps:
                        f.write(
                            f"- [{app.get('title', 'Application Portal')}]({app.get('url')})\n"
                        )
                    f.write("\n")

                # List external application references
                external_apps = [
                    a
                    for a in apps
                    if a.get("application_type") == "external_application_reference"
                    and a.get("is_actual_application", False)
                ]

                if external_apps:
                    f.write("#### External Application References\n\n")
                    for app in external_apps:
                        f.write(
                            f"- [{app.get('title', 'External System Reference')}]({app.get('url')})\n"
                        )
                    f.write("\n")

                # List information pages
                info_apps = [
                    a for a in apps if not a.get("is_actual_application", False)
                ]

                if info_apps:
                    f.write("#### Information Pages\n\n")
                    for app in info_apps[:5]:  # Limit to top 5 to avoid clutter
                        f.write(
                            f"- [{app.get('title', 'Information Page')}]({app.get('url')})\n"
                        )
                    f.write("\n")

            f.write("---\n\n")

    logger.success(f"Generated How to Apply report at {output_file}")
    return output_file


def export_how_to_apply_csv(evaluated_applications, output_file):
    """
    Export a simplified CSV with clear application instructions for undergraduate programs

    Args:
        evaluated_applications: List of evaluated application pages
        output_file: Path to save the CSV

    Returns:
        str: Path to the generated CSV
    """
    # Filter out graduate-specific application pages
    undergrad_applications = [
        a for a in evaluated_applications if is_undergraduate_page(a)
    ]

    # Group applications by university
    universities = {}
    for app in undergrad_applications:
        univ_name = app.get("university", "Unknown University")
        if univ_name not in universities:
            universities[univ_name] = []
        universities[univ_name].append(app)

    # Prepare data for CSV
    rows = []

    for univ_name, apps in universities.items():
        # Find the best application page
        best_app = find_best_application_page(apps, univ_name)

        if not best_app:
            continue  # Skip if no undergraduate page found

        # Detect external application system
        external_system = detect_external_system(best_app)

        row = {
            "University": univ_name,
            "Application Method": "",
            "Reference Page": "",
            "Application Portal": "",
            "External System": "",
            "Institution Code": "",
            "Notes": "",
        }

        if external_system:
            row["Application Method"] = f"External system: {external_system['name']}"
            row["Reference Page"] = best_app.get("url", "")
            row["External System"] = external_system["url"]
            if (
                "institution_code" in external_system
                and external_system["institution_code"]
            ):
                row["Institution Code"] = external_system["institution_code"]
            if "note" in external_system and external_system["note"]:
                row["Notes"] = external_system["note"]
        else:
            row["Application Method"] = "Direct university portal"
            row["Application Portal"] = best_app.get("url", "")

        # Add a brief excerpt from AI evaluation
        if "ai_evaluation" in best_app and best_app["ai_evaluation"]:
            excerpt = best_app["ai_evaluation"]
            if len(excerpt) > 200:
                excerpt = excerpt[:197] + "..."

            if row["Notes"]:
                row["Notes"] += " " + excerpt
            else:
                row["Notes"] = excerpt

        rows.append(row)

    # Write to CSV
    with open(output_file, "w", newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(
            f,
            fieldnames=[
                "University",
                "Application Method",
                "Reference Page",
                "Application Portal",
                "External System",
                "Institution Code",
                "Notes",
            ],
        )
        writer.writeheader()
        writer.writerows(rows)

    logger.success(f"Generated How to Apply CSV at {output_file}")
    return output_file



================================================
File: output/report_generator.py
================================================
"""
Report generator for more detailed analysis and visualization
"""

import os
from typing import List, Dict, Optional
import matplotlib.pyplot as plt
import pandas as pd
from datetime import datetime

from loguru import logger
from models.application_page import ApplicationPageCollection


class ReportGenerator:
    """Generate detailed reports and visualizations from crawler results."""

    def __init__(self, output_dir: str = "reports"):
        self.output_dir = output_dir
        os.makedirs(output_dir, exist_ok=True)

    def generate_full_report(
        self,
        application_pages: List[Dict],
        crawl_stats: Optional[Dict] = None,
        api_metrics: Optional[Dict] = None,
    ) -> str:
        """Generate a comprehensive HTML report with visualizations."""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        report_file = os.path.join(self.output_dir, f"full_report_{timestamp}.html")

        # Convert to pandas DataFrame for easier analysis
        df = pd.DataFrame(application_pages)

        # Generate visualizations
        self._generate_visualizations(df, timestamp)

        # Build HTML report
        with open(report_file, "w") as f:
            f.write("<html><head>")
            f.write("<style>")
            f.write("body { font-family: Arial, sans-serif; margin: 20px; }")
            f.write("h1, h2, h3 { color: #333366; }")
            f.write("table { border-collapse: collapse; width: 100%; }")
            f.write(
                "th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }"
            )
            f.write("tr:nth-child(even) { background-color: #f2f2f2; }")
            f.write("th { background-color: #4CAF50; color: white; }")
            f.write(".stats { display: flex; flex-wrap: wrap; }")
            f.write(
                ".stat-box { padding: 15px; margin: 10px; background-color: #f8f8f8; border-radius: 5px; flex: 1; }"
            )
            f.write("</style>")
            f.write("</head><body>")

            # Title and overview
            f.write(f"<h1>University Application Crawler Report</h1>")
            f.write(
                f"<p>Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>"
            )

            # Key statistics
            f.write("<h2>Key Statistics</h2>")
            f.write("<div class='stats'>")

            # Application pages stats
            actual_pages = len(
                [p for p in application_pages if p.get("is_actual_application", False)]
            )
            f.write(f"<div class='stat-box'><h3>Found Pages</h3>")
            f.write(f"<p>Total pages analyzed: {len(application_pages)}</p>")
            f.write(f"<p>Actual application pages: {actual_pages}</p>")
            f.write(
                f"<p>Success rate: {actual_pages/len(application_pages)*100:.1f}%</p>"
            )
            f.write("</div>")

            # Crawl stats if available
            if crawl_stats:
                f.write(f"<div class='stat-box'><h3>Crawl Performance</h3>")
                f.write(
                    f"<p>URLs visited: {crawl_stats.get('total_urls_visited', 0)}</p>"
                )
                f.write(
                    f"<p>Domains explored: {len(crawl_stats.get('domain_visit_counts', {}))}</p>"
                )
                f.write(
                    f"<p>Admission domains found: {len(crawl_stats.get('admission_related_domains', []))}</p>"
                )
                f.write("</div>")

            # API metrics if available
            if api_metrics:
                f.write(f"<div class='stat-box'><h3>AI Evaluation</h3>")
                f.write(
                    f"<p>Pages evaluated: {api_metrics.get('pages_evaluated', 0)}</p>"
                )
                f.write(f"<p>Total tokens: {api_metrics.get('total_tokens', 0)}</p>")
                f.write(
                    f"<p>Cost: ${api_metrics.get('estimated_cost_usd', 0.0):.4f}</p>"
                )
                f.write("</div>")

            f.write("</div>")  # Close stats div

            # Visualizations
            f.write("<h2>Visualizations</h2>")
            f.write("<div style='display: flex; flex-wrap: wrap;'>")
            f.write(
                f"<div style='flex: 1;'><img src='university_distribution_{timestamp}.png' width='100%'></div>"
            )
            f.write(
                f"<div style='flex: 1;'><img src='application_types_{timestamp}.png' width='100%'></div>"
            )
            f.write("</div>")

            # University breakdown
            f.write("<h2>Results by University</h2>")

            # Group by university
            by_university = {}
            for app in application_pages:
                univ = app.get("university", "Unknown")
                if univ not in by_university:
                    by_university[univ] = []
                by_university[univ].append(app)

            # Create a table of universities and their application pages
            for univ, apps in by_university.items():
                actual_apps = [a for a in apps if a.get("is_actual_application", False)]

                f.write(f"<h3>{univ}</h3>")
                f.write(
                    f"<p>Found {len(apps)} potential pages, {len(actual_apps)} actual application pages</p>"
                )

                # Table of actual application pages
                if actual_apps:
                    f.write("<h4>Actual Application Pages</h4>")
                    f.write("<table>")
                    f.write("<tr><th>Title</th><th>URL</th><th>AI Evaluation</th></tr>")

                    for app in actual_apps:
                        f.write("<tr>")
                        f.write(f"<td>{app.get('title', 'No title')}</td>")
                        f.write(
                            f"<td><a href='{app.get('url', '')}' target='_blank'>{app.get('url', '')}</a></td>"
                        )
                        f.write(f"<td>{app.get('ai_evaluation', 'No evaluation')}</td>")
                        f.write("</tr>")

                    f.write("</table>")

                # Table of information pages
                info_apps = [
                    a for a in apps if not a.get("is_actual_application", False)
                ]
                if info_apps:
                    f.write("<h4>Information Pages</h4>")
                    f.write("<table>")
                    f.write("<tr><th>Title</th><th>URL</th><th>AI Evaluation</th></tr>")

                    for app in info_apps:
                        f.write("<tr>")
                        f.write(f"<td>{app.get('title', 'No title')}</td>")
                        f.write(
                            f"<td><a href='{app.get('url', '')}' target='_blank'>{app.get('url', '')}</a></td>"
                        )
                        f.write(f"<td>{app.get('ai_evaluation', 'No evaluation')}</td>")
                        f.write("</tr>")

                    f.write("</table>")

            # Close HTML
            f.write("</body></html>")

        logger.success(f"Generated full HTML report at {report_file}")
        return report_file

    def _generate_visualizations(self, df, timestamp):
        """Generate visualization images for the report."""
        try:
            # University distribution chart
            plt.figure(figsize=(10, 6))
            university_counts = df["university"].value_counts()
            university_counts.plot(kind="bar", color="skyblue")
            plt.title("Pages Found by University")
            plt.xlabel("University")
            plt.ylabel("Number of Pages")
            plt.tight_layout()
            plt.savefig(
                os.path.join(
                    self.output_dir, f"university_distribution_{timestamp}.png"
                )
            )
            plt.close()

            # Application types pie chart
            plt.figure(figsize=(8, 8))
            app_types = df["is_actual_application"].value_counts()
            labels = ["Application Pages", "Information Pages"]
            plt.pie(
                app_types,
                labels=labels,
                autopct="%1.1f%%",
                colors=["#4CAF50", "#FFC107"],
            )
            plt.title("Types of Pages Found")
            plt.tight_layout()
            plt.savefig(
                os.path.join(self.output_dir, f"application_types_{timestamp}.png")
            )
            plt.close()

        except Exception as e:
            logger.error(f"Error generating visualizations: {e}")



================================================
File: output/special_cases.py
================================================
"""
Special case definitions for university application systems.

This file contains mappings and rules for universities with unique application processes
or those that use specific external application systems.
"""

# Dictionary of known external application systems with their official URLs
EXTERNAL_APPLICATION_SYSTEMS = {
    "ucas": {
        "name": "UCAS (Universities and Colleges Admissions Service)",
        "url": "https://www.ucas.com/apply",
        "description": "The central application service for UK undergraduate programs",
    },
    "common_app": {
        "name": "Common Application",
        "url": "https://apply.commonapp.org/login",
        "description": "Application platform for over 900 colleges and universities, primarily in the US",
    },
    "coalition": {
        "name": "Coalition Application",
        "url": "https://app.coalitionforcollegeaccess.org/",
        "description": "Alternative to Common App, used by about 150 US colleges and universities",
    },
    "uc_application": {
        "name": "University of California Application",
        "url": "https://apply.universityofcalifornia.edu/my-application/login",
        "description": "Central application for all University of California campuses",
    },
    "cal_state_apply": {
        "name": "Cal State Apply",
        "url": "https://www.calstate.edu/apply",
        "description": "Application portal for all California State University campuses",
    },
    "applytexas": {
        "name": "ApplyTexas",
        "url": "https://www.applytexas.org/adappc/gen/c_start.WBX",
        "description": "Application system for Texas public universities and community colleges",
    },
    "ouac": {
        "name": "Ontario Universities' Application Centre",
        "url": "https://www.ouac.on.ca/apply/",
        "description": "Central application service for universities in Ontario, Canada",
    },
    "uac": {
        "name": "Universities Admissions Centre (Australia)",
        "url": "https://www5.uac.edu.au/uacug/",
        "description": "Central admissions for undergraduate study at participating institutions in NSW and ACT, Australia",
    },
    "studylink": {
        "name": "StudyLink (New Zealand)",
        "url": "https://www.studylink.govt.nz/apply/",
        "description": "New Zealand's student loan and allowance application system",
    },
    "uni_assist": {
        "name": "uni-assist (Germany)",
        "url": "https://www.uni-assist.de/en/how-to-apply/",
        "description": "Application service for international students applying to German universities",
    },
}

# Special case mappings for specific universities and domains
UNIVERSITY_SPECIAL_CASES = {
    # UK Universities that use UCAS
    "University of Cambridge": {
        "system": "ucas",
        "note": "All undergraduate applications to Cambridge must be submitted through UCAS",
        "application_portal": "https://www.ucas.com/apply",
        "institution_code": "CAM C05",
    },
    "University of Oxford": {
        "system": "ucas",
        "note": "All undergraduate applications to Oxford must be submitted through UCAS",
        "application_portal": "https://www.ucas.com/apply",
        "institution_code": "OXFORD O33",
    },
    "Imperial College London": {
        "system": "ucas",
        "note": "All undergraduate applications to Imperial must be submitted through UCAS",
        "application_portal": "https://www.ucas.com/apply",
        "institution_code": "IMPERIAL I50",
    },
    "UCL": {
        "system": "ucas",
        "note": "All undergraduate applications to UCL must be submitted through UCAS",
        "application_portal": "https://www.ucas.com/apply",
        "institution_code": "UCL U80",
    },
    # University of California system
    "University of California, Berkeley": {
        "system": "uc_application",
        "note": "All UC campuses use the same application portal",
        "application_portal": "https://apply.universityofcalifornia.edu/my-application/login",
        "alternate_names": ["UC Berkeley", "Berkeley", "Cal"],
    },
    "University of California, Los Angeles": {
        "system": "uc_application",
        "note": "All UC campuses use the same application portal",
        "application_portal": "https://apply.universityofcalifornia.edu/my-application/login",
        "alternate_names": ["UCLA"],
    },
    "University of California, San Diego": {
        "system": "uc_application",
        "note": "All UC campuses use the same application portal",
        "application_portal": "https://apply.universityofcalifornia.edu/my-application/login",
        "alternate_names": ["UCSD"],
    },
    "University of California, Davis": {
        "system": "uc_application",
        "note": "All UC campuses use the same application portal",
        "application_portal": "https://apply.universityofcalifornia.edu/my-application/login",
        "alternate_names": ["UC Davis", "UCD"],
    },
    "University of California, Irvine": {
        "system": "uc_application",
        "note": "All UC campuses use the same application portal",
        "application_portal": "https://apply.universityofcalifornia.edu/my-application/login",
        "alternate_names": ["UC Irvine", "UCI"],
    },
    "University of California, Santa Barbara": {
        "system": "uc_application",
        "note": "All UC campuses use the same application portal",
        "application_portal": "https://apply.universityofcalifornia.edu/my-application/login",
        "alternate_names": ["UC Santa Barbara", "UCSB"],
    },
    "University of California, Santa Cruz": {
        "system": "uc_application",
        "note": "All UC campuses use the same application portal",
        "application_portal": "https://apply.universityofcalifornia.edu/my-application/login",
        "alternate_names": ["UC Santa Cruz", "UCSC"],
    },
    "University of California, Riverside": {
        "system": "uc_application",
        "note": "All UC campuses use the same application portal",
        "application_portal": "https://apply.universityofcalifornia.edu/my-application/login",
        "alternate_names": ["UC Riverside", "UCR"],
    },
    "University of California, Merced": {
        "system": "uc_application",
        "note": "All UC campuses use the same application portal",
        "application_portal": "https://apply.universityofcalifornia.edu/my-application/login",
        "alternate_names": ["UC Merced", "UCM"],
    },
    # California State University System
    "California State University": {
        "system": "cal_state_apply",
        "note": "All CSU campuses use the same application portal",
        "application_portal": "https://www.calstate.edu/apply",
        "alternate_names": ["Cal State", "CSU"],
    },
    # ApplyTexas universities
    "University of Texas at Austin": {
        "system": "applytexas",
        "note": "UT Austin uses the ApplyTexas application system",
        "application_portal": "https://www.applytexas.org/adappc/gen/c_start.WBX",
        "alternate_names": ["UT Austin", "UT"],
    },
    "Texas A&M University": {
        "system": "applytexas",
        "note": "Texas A&M uses the ApplyTexas application system",
        "application_portal": "https://www.applytexas.org/adappc/gen/c_start.WBX",
        "alternate_names": ["Texas A&M", "TAMU"],
    },
}

# Domain pattern special cases
DOMAIN_PATTERNS = [
    # UK universities (.ac.uk) generally use UCAS for undergraduate applications
    {
        "pattern": r"\.ac\.uk",
        "system": "ucas",
        "note": "UK universities use UCAS for undergraduate applications",
        "application_portal": "https://www.ucas.com/apply",
    },
    # University of California domains
    {
        "pattern": r".*\.berkeley\.edu",
        "system": "uc_application",
        "note": "All UC campuses use the same application portal",
        "application_portal": "https://apply.universityofcalifornia.edu/my-application/login",
    },
    {
        "pattern": r".*\.ucla\.edu",
        "system": "uc_application",
        "note": "All UC campuses use the same application portal",
        "application_portal": "https://apply.universityofcalifornia.edu/my-application/login",
    },
    {
        "pattern": r".*\.ucsd\.edu",
        "system": "uc_application",
        "note": "All UC campuses use the same application portal",
        "application_portal": "https://apply.universityofcalifornia.edu/my-application/login",
    },
    {
        "pattern": r".*\.ucdavis\.edu",
        "system": "uc_application",
        "note": "All UC campuses use the same application portal",
        "application_portal": "https://apply.universityofcalifornia.edu/my-application/login",
    },
    {
        "pattern": r".*\.uci\.edu",
        "system": "uc_application",
        "note": "All UC campuses use the same application portal",
        "application_portal": "https://apply.universityofcalifornia.edu/my-application/login",
    },
    # Common App participating schools often have specific information
    {
        "pattern": r"commonapp\.org",
        "system": "common_app",
        "note": "This refers to the Common Application system used by many US colleges",
        "application_portal": "https://apply.commonapp.org/login",
    },
    # Coalition App
    {
        "pattern": r"coalitionforcollegeaccess\.org",
        "system": "coalition",
        "note": "This refers to the Coalition Application system",
        "application_portal": "https://app.coalitionforcollegeaccess.org/",
    },
]

# Indicators to help identify graduate vs undergraduate pages
GRADUATE_INDICATORS = [
    "graduate",
    "grad",
    "phd",
    "doctoral",
    "master",
    "postgraduate",
    "mba",
    "msc",
    "ma ",
    "ms ",
    "doctorate",
]

UNDERGRADUATE_INDICATORS = [
    "undergraduate",
    "undergrad",
    "freshman",
    "freshmen",
    "first-year",
    "first year",
    "bachelor",
    "transfer",
    "high school",
    "college",
]


def get_special_case_for_university(university_name):
    """Get special case information for a university by name."""
    # Check direct match
    if university_name in UNIVERSITY_SPECIAL_CASES:
        return UNIVERSITY_SPECIAL_CASES[university_name]

    # Check alternate names
    for univ, info in UNIVERSITY_SPECIAL_CASES.items():
        if "alternate_names" in info:
            if university_name in info["alternate_names"]:
                return info

    # No special case found
    return None


def get_special_case_for_domain(url):
    """Get special case information based on URL domain pattern matching."""
    import re

    for pattern_info in DOMAIN_PATTERNS:
        if re.search(pattern_info["pattern"], url, re.IGNORECASE):
            return pattern_info

    return None


def is_undergraduate_page(page):
    """
    Determine if a page is related to undergraduate (not graduate) applications.

    Args:
        page: The application page dictionary

    Returns:
        bool: True if the page is likely for undergraduate applications
    """
    # Skip graduate pages
    title = page.get("title", "").lower()
    url = page.get("url", "").lower()

    # Check for graduate indicators in title or URL
    if any(grad in title for grad in GRADUATE_INDICATORS):
        return False
    if any(grad in url for grad in GRADUATE_INDICATORS):
        return False

    # Check for specific graduate domains
    if "gradadmissions" in url or "graduate.admissions" in url:
        return False

    # Check if it explicitly mentions undergraduate
    if any(ugrad in title for ugrad in UNDERGRADUATE_INDICATORS):
        return True
    if any(ugrad in url for ugrad in UNDERGRADUATE_INDICATORS):
        return True

    # Default to including the page if no graduate indicators found
    return True





================================================
File: utils/__init__.py
================================================



================================================
File: utils/encoding.py
================================================
"""
Text encoding detection and conversion utilities
"""

import re
from urllib.parse import urlparse, quote

import aiohttp
from loguru import logger


class EncodingHandler:
    """Handles text encoding detection and conversion."""

    # Common fallback encodings to try
    FALLBACK_ENCODINGS = ["utf-8", "latin-1", "cp1252", "iso-8859-1"]

    @staticmethod
    def detect_encoding_from_headers(headers):
        """Detect encoding from HTTP headers."""
        content_type = headers.get("content-type", "")
        if "charset=" in content_type:
            encoding = content_type.split("charset=")[-1].strip()
            # Clean up encoding name
            if ";" in encoding:
                encoding = encoding.split(";")[0]
            if encoding.startswith('"') and encoding.endswith('"'):
                encoding = encoding[1:-1]
            return encoding
        return None

    @staticmethod
    def detect_encoding_from_html(html_bytes):
        """Detect encoding from HTML meta tags."""
        # Try to decode as ASCII first to find meta tags
        try:
            html_start = html_bytes[:4096].decode("ascii", errors="ignore")
            # Check for meta charset
            meta_match = re.search(
                r'<meta[^>]+charset=["\'](.*?)["\']', html_start, re.IGNORECASE
            )
            if meta_match:
                return meta_match.group(1)

            # Check for XML declaration
            xml_match = re.search(
                r'<\?xml[^>]+encoding=["\'](.*?)["\']', html_start, re.IGNORECASE
            )
            if xml_match:
                return xml_match.group(1)

            # Check for content-type meta
            content_type_match = re.search(
                r'<meta[^>]+http-equiv=["\'](content-type)["\'][^>]+content=["\'](.*?)["\']',
                html_start,
                re.IGNORECASE,
            )
            if content_type_match and "charset=" in content_type_match.group(2).lower():
                charset = (
                    content_type_match.group(2).lower().split("charset=")[-1].strip()
                )
                if ";" in charset:
                    charset = charset.split(";")[0]
                return charset

        except Exception as e:
            logger.warning(f"Error detecting encoding from HTML: {e}")

        return None

    @staticmethod
    async def decode_html(response):
        """Decode HTML content with proper encoding detection."""
        # Get raw bytes
        html_bytes = await response.read()

        # Try from HTTP headers first
        encoding = EncodingHandler.detect_encoding_from_headers(response.headers)

        # If no encoding in headers, try from HTML content
        if not encoding:
            encoding = EncodingHandler.detect_encoding_from_html(html_bytes)

        # If encoding detected, try to decode
        if encoding:
            try:
                return html_bytes.decode(encoding, errors="replace")
            except (LookupError, UnicodeDecodeError) as e:
                logger.warning(
                    f"Failed to decode using detected encoding {encoding}: {e}"
                )

        # Try fallback encodings
        for enc in EncodingHandler.FALLBACK_ENCODINGS:
            try:
                return html_bytes.decode(enc, errors="replace")
            except (LookupError, UnicodeDecodeError):
                continue

        # Last resort: force decode with replace
        return html_bytes.decode("utf-8", errors="replace")


class HTMLCleaner:
    """Helper class for cleaning and extracting content from HTML."""

    @staticmethod
    def clean_text(text):
        """Clean text by removing extra whitespace and normalizing."""
        if not text:
            return ""

        # Replace HTML entities
        text = re.sub(r"&amp;", "&", text)
        text = re.sub(r"&lt;", "<", text)
        text = re.sub(r"&gt;", ">", text)
        text = re.sub(r"&quot;", '"', text)
        text = re.sub(r"&nbsp;", " ", text)
        text = re.sub(r"&#(\d+);", lambda m: chr(int(m.group(1))), text)

        # Normalize whitespace
        text = re.sub(r"\s+", " ", text)

        return text.strip()

    @staticmethod
    def extract_meta_description(html):
        """Extract meta description from HTML."""
        if not html:
            return ""

        meta_desc_match = re.search(
            r'<meta[^>]*name=["\']description["\'][^>]*content=["\'](.*?)["\']',
            html,
            re.IGNORECASE,
        )

        if meta_desc_match:
            return HTMLCleaner.clean_text(meta_desc_match.group(1))

        return ""

    @staticmethod
    def extract_text_from_html(html, max_length=1000):
        """Extract plain text from HTML by removing tags (simple version)."""
        if not html:
            return ""

        # Remove scripts and style sections
        html = re.sub(
            r"<script.*?</script>", " ", html, flags=re.DOTALL | re.IGNORECASE
        )
        html = re.sub(r"<style.*?</style>", " ", html, flags=re.DOTALL | re.IGNORECASE)

        # Remove comments
        html = re.sub(r"<!--.*?-->", " ", html, flags=re.DOTALL)

        # Remove tags while keeping their content
        text = re.sub(r"<[^>]*>", " ", html)

        # Clean the text
        text = HTMLCleaner.clean_text(text)

        # Truncate if needed
        if max_length and len(text) > max_length:
            return text[:max_length] + "..."

        return text



================================================
File: utils/logging_config.py
================================================
"""
Logging configuration using Loguru
"""

import sys
import os
from loguru import logger


def configure_logging(log_file="crawler.log", log_level="INFO"):
    """Configure Loguru logger with appropriate formats and outputs."""
    # Remove default handler
    logger.remove()

    # Add stderr handler with color
    logger.add(
        sys.stderr,
        format="<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level: <8}</level> | <level>{message}</level>",
        level=log_level,
        colorize=True,
    )

    # Add file handler with rotation
    logger.add(
        log_file,
        rotation="10 MB",
        format="{time:YYYY-MM-DD HH:mm:ss} | {level: <8} | {message}",
        level=log_level,
    )

    # Add special file handler for errors only
    logger.add(
        "errors.log",
        rotation="5 MB",
        format="{time:YYYY-MM-DD HH:mm:ss} | {level: <8} | {message}\n{exception}",
        level="ERROR",
        backtrace=True,
        diagnose=True,
    )

    logger.info("Logging configured successfully")


def get_custom_logger(name):
    """Get a logger with context information."""
    return logger.bind(name=name)


# Define custom log levels
def add_custom_levels():
    """Add custom log levels for the crawler."""
    # Success level for found application pages
    logger.level("SUCCESS", no=25, color="<green>")

    # Special level for crawler insights
    logger.level("INSIGHT", no=15, color="<cyan>")


# Define custom log formats for specific contexts
def add_log_context(crawler_name, run_id):
    """Add custom context to log messages."""
    logger.configure(extra={"crawler": crawler_name, "run_id": run_id})

    # Now you can access these in format strings like:
    # format="{extra[crawler]} | {extra[run_id]} | {message}"



================================================
File: utils/url_utils.py
================================================
"""
Standardized URL processing and validation utilities
"""

import re
import urllib.robotparser
from urllib.parse import urlparse, urljoin, parse_qs, urlencode, quote

from loguru import logger
from config import Config


def normalize_url(url):
    """
    Enhanced URL normalization that prevents loops and cleans malformed URLs
    """
    if not url:
        return url

    try:
        # Clean common problematic characters from URLs
        # This handles cases where HTML or quotes get into URLs
        for char in ["<", ">", '"', "'", "\\", "\n", "\r", "\t"]:
            url = url.replace(char, "")

        # Replace URL-encoded versions of these characters too
        url = url.replace("%22", "")  # Encoded quote
        url = url.replace("%3C", "")  # Encoded <
        url = url.replace("%3E", "")  # Encoded >

        # Parse URL
        parsed = urlparse(url)

        # Normalize scheme to lowercase
        scheme = parsed.scheme.lower()
        if not scheme:
            scheme = "http"

        # Remove fragment
        parsed = parsed._replace(fragment="", scheme=scheme)

        # Handle query parameters (remove tracking parameters)
        if parsed.query:
            query_dict = parse_qs(parsed.query)
            # Remove common tracking parameters
            for param in [
                "utm_source",
                "utm_medium",
                "utm_campaign",
                "utm_term",
                "utm_content",
                "fbclid",
                "gclid",
                "ref",
                "source",
                "mc_cid",
                "mc_eid",
                "_ga",
            ]:
                if param in query_dict:
                    del query_dict[param]

            # Rebuild query string in sorted order for consistency
            if query_dict:
                query_parts = []
                for key in sorted(query_dict.keys()):
                    for value in sorted(query_dict[key]):
                        query_parts.append(f"{key}={value}")
                new_query = "&".join(query_parts)
            else:
                new_query = ""

            parsed = parsed._replace(query=new_query)

        # Process and normalize the path
        path = parsed.path

        # Ensure path starts with / if it exists
        if path and not path.startswith("/"):
            path = "/" + path

        # Remove trailing slash for non-root paths
        if path.endswith("/") and len(path) > 1:
            path = path[:-1]

        # Fix repeating path segments - this addresses loop issues
        path_parts = [p for p in path.split("/") if p]
        clean_parts = []

        for part in path_parts:
            # Don't add if it would create a repeat
            if not clean_parts or part != clean_parts[-1]:
                clean_parts.append(part)

        # Reconstruct the path
        clean_path = "/" + "/".join(clean_parts)
        if not clean_path or clean_path == "/":
            clean_path = "/"

        # URL-encode the path (preserving slashes)
        clean_path = quote(clean_path, safe="/%")
        parsed = parsed._replace(path=clean_path)

        # Handle IDN domains (Unicode to Punycode)
        hostname = parsed.netloc.encode("idna").decode("ascii")
        parsed = parsed._replace(netloc=hostname)

        # Final URL
        final_url = parsed.geturl()

        # One last safety check for max length
        if len(final_url) > 2000:  # Common URL length limit
            logger.warning(
                f"URL exceeds maximum length, truncating: {final_url[:50]}..."
            )
            return final_url[:2000]

        return final_url
    except Exception as e:
        logger.warning(f"Error normalizing URL {url}: {e}")
        # Try to return something useful if possible
        sanitized = re.sub(r'[<>"\'\\]', "", url)
        return sanitized[:2000] if len(sanitized) > 2000 else sanitized


def is_valid_url(url, config_obj=None):
    """Check if a URL should be crawled based on patterns and extensions."""
    # Use passed config or default to global Config
    cfg = config_obj or Config

    if not url:
        return False

    # Check for invalid schemes
    if not url.startswith(("http://", "https://")):
        return False

    # Parse URL
    parsed = urlparse(url)

    # Check for excluded extensions
    path = parsed.path.lower()
    if any(path.endswith(ext) for ext in cfg.EXCLUDED_EXTENSIONS):
        return False

    # Check for excluded patterns
    if any(re.search(pattern, path) for pattern in cfg.EXCLUDED_PATTERNS):
        return False

    return True


def join_url(base, relative):
    """Safely join a base URL and a relative URL."""
    try:
        return urljoin(base, relative)
    except Exception as e:
        logger.error(f"Error joining URLs {base} and {relative}: {e}")
        return None


def get_domain_from_url(url):
    """Extract the domain from a URL."""
    try:
        parsed = urlparse(url)
        return parsed.netloc.lower()
    except Exception as e:
        logger.error(f"Error extracting domain from {url}: {e}")
        return ""


def get_path_from_url(url):
    """Extract the path from a URL."""
    try:
        parsed = urlparse(url)
        return parsed.path.lower()
    except Exception as e:
        logger.error(f"Error extracting path from {url}: {e}")
        return ""


def is_related_domain(university_domain, url_domain, university_name):
    """Check if a domain is likely related to a university domain."""
    url_domain_lower = url_domain.lower()

    # Direct match
    if university_domain in url_domain_lower:
        return True

    # Special handling for admission-related subdomains (highest priority)
    if any(
        term in url_domain_lower
        for term in ["admission", "apply", "undergrad", "applicant"]
    ):
        university_root = university_domain.split(".")[
            -2
        ]  # e.g., 'stanford' from 'stanford.edu'
        if university_root in url_domain_lower:
            logger.info(
                f"Found critical admission domain: {url_domain} for {university_name}"
            )
            return True

    # Common patterns for university-related domains
    related_patterns = [
        r"apply\.",
        r"admission[s]?\.",
        r"undergrad\.",
        r"student\.",
        r"portal\.",
        r"applicant\.",
        r"freshman\.",
        r"myapp\.",
        r"commonapp\.",
    ]

    for pattern in related_patterns:
        if re.search(pattern, url_domain_lower):
            logger.info(f"Found related domain: {url_domain} for {university_name}")
            return True

    # Check for university name in domain
    university_name_parts = university_name.lower().split()

    # Handle abbreviations (e.g., MIT)
    if len(university_name_parts) > 1:
        abbreviation = "".join(
            word[0] for word in university_name_parts if len(word) > 1
        )
        if len(abbreviation) >= 2 and abbreviation.lower() in url_domain_lower:
            logger.info(
                f"Found related domain by abbreviation: {url_domain} for {university_name}"
            )
            return True

    # Check for parts of university name
    for part in university_name_parts:
        if len(part) > 3 and part.lower() in url_domain_lower:
            logger.info(
                f"Found related domain by name: {url_domain} for {university_name}"
            )
            return True

    return False


def get_url_priority(url, university):
    """Determine priority for a URL (lower is higher priority)."""
    parsed = urlparse(url)
    domain = parsed.netloc.lower()
    path = parsed.path.lower()

    # Highest priority: Look for exact application paths
    if any(
        pattern in path
        for pattern in ["/apply/first-year", "/admission/apply", "/apply/undergraduate"]
    ):
        return 0

    # Second highest: Admission subdomains with application paths
    if ("admission" in domain or "apply" in domain or "undergrad" in domain) and any(
        p in path
        for p in ["/apply", "/admission", "/application", "/portal", "/first-year"]
    ):
        return 1

    # Third highest: General admission subdomains
    if any(x in domain for x in ["admission", "apply", "undergrad", "freshman"]):
        return 2

    # Fourth highest: Important paths on any domain
    for i, pattern in enumerate(Config.HIGH_PRIORITY_PATTERNS):
        if pattern in path:
            return 3 + (i * 0.1)  # Small increments to maintain ordering of patterns

    # Fifth highest: URLs with application keywords in path
    if any(keyword in path for keyword in Config.APPLICATION_KEYWORDS):
        return 5

    # Default priority - consider depth from homepage
    segments = [s for s in path.split("/") if s]
    return 10 + len(segments)


class RobotsChecker:
    """Class to check and respect robots.txt rules."""

    def __init__(self):
        self.parsers = {}  # Cache for robot parsers by domain
        self.user_agent = Config.USER_AGENT

    def set_user_agent(self, user_agent):
        """Set the user agent string to use for checking permissions."""
        self.user_agent = user_agent

    def _get_parser(self, domain):
        """Get or create a parser for a domain."""
        if domain in self.parsers:
            return self.parsers[domain]

        try:
            parser = urllib.robotparser.RobotFileParser()
            robots_url = f"https://{domain}/robots.txt"
            parser.set_url(robots_url)
            parser.read()
            self.parsers[domain] = parser
            return parser
        except Exception as e:
            logger.warning(f"Error reading robots.txt for {domain}: {e}")
            # Return a permissive parser on error
            parser = urllib.robotparser.RobotFileParser()
            self.parsers[domain] = parser
            return parser

    def can_fetch(self, url):
        """Check if the URL can be fetched according to robots.txt."""
        try:
            parsed = urlparse(url)
            domain = parsed.netloc

            if not domain:
                return True  # Can't check without a domain

            parser = self._get_parser(domain)
            return parser.can_fetch(self.user_agent, url)
        except Exception as e:
            logger.warning(f"Error checking robots permission for {url}: {e}")
            return True  # Be permissive on error



